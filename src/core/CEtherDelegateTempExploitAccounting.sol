pragma solidity ^0.5.17;

import "./CEther.sol";

/**
 * @title Compound's CEtherDelegate Contract
 * @notice CTokens which wrap Ether and are delegated to
 * @author Compound
 */
contract CEtherDelegateTempExploitAccounting is CDelegateInterface, CEther {
    /**
     * @notice Construct an empty delegate
     */
    constructor() public {}

    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes calldata data) external {
        // Shh -- we don't ever want this hook to be marked pure
        if (false) {
            implementation = address(0);
        }

        require(msg.sender == address(this) || hasAdminRights(), "!self");
        require(accrueInterest() == uint256(Error.NO_ERROR), "!accrue");

        // Get secondary accounts from data
        address[] memory secondaryAccounts = abi.decode(data, (address[]));
        uint256 secondaryAccountsBorrowBalance = 0;

        for (uint256 i = 0; i < secondaryAccounts.length; i++) {
            address secondaryAccount = secondaryAccounts[i];

            // Get account #2 borrow balance
            uint256 secondaryAccountBorrowBalance = div_(
                mul_(accountBorrows[secondaryAccount].principal, borrowIndex),
                accountBorrows[secondaryAccount].interestIndex
            );
            secondaryAccountsBorrowBalance = add_(
                secondaryAccountsBorrowBalance,
                secondaryAccountBorrowBalance
            );

            // Set account #2 borrow balance to 0
            accountBorrows[secondaryAccount].principal = 0;
            accountBorrows[secondaryAccount].interestIndex = borrowIndex;
        }

        // Get account #1 supply balance
        uint256 account1SupplyShares = accountTokens[
            0x32075bAd9050d4767018084F0Cb87b3182D36C45
        ];
        uint256 account1SupplyBalance = mul_ScalarTruncate(
            Exp({mantissa: exchangeRateStored()}),
            account1SupplyShares
        );

        // Set account #1 supply shares to 0
        accountTokens[0x32075bAd9050d4767018084F0Cb87b3182D36C45] = 0;

        // Set account #1 borrow balance = secondary accounts' borrow balance - account #1 supply balance
        require(
            secondaryAccountsBorrowBalance >= account1SupplyBalance,
            "Expect secondary accounts' combined borrow balance >= account #1 supply balance."
        );
        require(
            accountBorrows[0x32075bAd9050d4767018084F0Cb87b3182D36C45]
                .principal == 0,
            "Expect account #1 borrow balance to start at 0."
        );
        accountBorrows[0x32075bAd9050d4767018084F0Cb87b3182D36C45]
            .principal = sub_(
            secondaryAccountsBorrowBalance,
            account1SupplyBalance
        );
        accountBorrows[0x32075bAd9050d4767018084F0Cb87b3182D36C45]
            .interestIndex = borrowIndex;

        // Subtract from total supply
        totalSupply = sub_(totalSupply, account1SupplyShares);

        // Subtract from total borrows
        totalBorrows = sub_(totalBorrows, account1SupplyBalance);
    }

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() internal {
        // Shh -- we don't ever want this hook to be marked pure
        if (false) {
            implementation = address(0);
        }
    }

    /**
     * @dev Internal function to update the implementation of the delegator
     * @param implementation_ The address of the new implementation for delegation
     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
     */
    function _setImplementationInternal(
        address implementation_,
        bool allowResign,
        bytes memory becomeImplementationData
    ) internal {
        // Check whitelist
        require(
            fuseAdmin.cEtherDelegateWhitelist(
                implementation,
                implementation_,
                allowResign
            ),
            "!impl"
        );

        // Call _resignImplementation internally (this delegate's code)
        if (allowResign) _resignImplementation();

        // Get old implementation
        address oldImplementation = implementation;

        // Store new implementation
        implementation = implementation_;

        // Call _becomeImplementation externally (delegating to new delegate's code)
        _functionCall(
            address(this),
            abi.encodeWithSignature(
                "_becomeImplementation(bytes)",
                becomeImplementationData
            ),
            "!become"
        );

        // Emit event
        emit NewImplementation(oldImplementation, implementation);
    }

    /**
     * @notice Called by the admin to update the implementation of the delegator
     * @param implementation_ The address of the new implementation for delegation
     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
     */
    function _setImplementationSafe(
        address implementation_,
        bool allowResign,
        bytes calldata becomeImplementationData
    ) external {
        // Check admin rights
        require(hasAdminRights(), "!admin");

        // Set implementation
        _setImplementationInternal(
            implementation_,
            allowResign,
            becomeImplementationData
        );
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     * Copied from `CErc20.sol`.
     * @param data The call data (encoded using abi.encode or one of its variants).
     * @param errorMessage The revert string to return on failure.
     */
    function _functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.call(data);

        if (!success) {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }

        return returndata;
    }

    /**
     * @notice Function called before all delegator functions
     */
    function _prepare() external payable {}

    /**
     * @notice Returns a boolean indicating if the sender has admin rights
     */
    function hasAdminRights() internal view returns (bool) {
        ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(
            address(comptroller)
        );
        return
            (msg.sender == comptrollerStorage.admin() &&
                comptrollerStorage.adminHasRights()) ||
            (msg.sender == address(fuseAdmin) &&
                comptrollerStorage.fuseAdminHasRights());
    }
}
