diff -x .git -r ../compound-protocol/contracts/BaseJumpRateModelV2.sol src/core/BaseJumpRateModelV2.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
6,9c6,9
<   * @title Logic for Compound's JumpRateModel Contract V2.
<   * @author Compound (modified by Dharma Labs, refactored by Arr00)
<   * @notice Version 2 modifies Version 1 by enabling updateable parameters.
<   */
---
>  * @title Logic for Compound's JumpRateModel Contract V2.
>  * @author Compound (modified by Dharma Labs, refactored by Arr00)
>  * @notice Version 2 modifies Version 1 by enabling updateable parameters.
>  */
11c11
<     using SafeMath for uint;
---
>     using SafeMath for uint256;
13c13,18
<     event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);
---
>     event NewInterestParams(
>         uint256 baseRatePerBlock,
>         uint256 multiplierPerBlock,
>         uint256 jumpMultiplierPerBlock,
>         uint256 kink
>     );
23c28
<     uint public constant blocksPerYear = 2102400;
---
>     uint256 public constant blocksPerYear = 2372500; // 6500 blocks/day * 365 days/year
28c33
<     uint public multiplierPerBlock;
---
>     uint256 public multiplierPerBlock;
33c38
<     uint public baseRatePerBlock;
---
>     uint256 public baseRatePerBlock;
38c43
<     uint public jumpMultiplierPerBlock;
---
>     uint256 public jumpMultiplierPerBlock;
43c48
<     uint public kink;
---
>     uint256 public kink;
53c58,64
<     constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) internal {
---
>     constructor(
>         uint256 baseRatePerYear,
>         uint256 multiplierPerYear,
>         uint256 jumpMultiplierPerYear,
>         uint256 kink_,
>         address owner_
>     ) internal {
56c67,72
<         updateJumpRateModelInternal(baseRatePerYear,  multiplierPerYear, jumpMultiplierPerYear, kink_);
---
>         updateJumpRateModelInternal(
>             baseRatePerYear,
>             multiplierPerYear,
>             jumpMultiplierPerYear,
>             kink_
>         );
66c82,87
<     function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) external {
---
>     function updateJumpRateModel(
>         uint256 baseRatePerYear,
>         uint256 multiplierPerYear,
>         uint256 jumpMultiplierPerYear,
>         uint256 kink_
>     ) external {
69c90,95
<         updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);
---
>         updateJumpRateModelInternal(
>             baseRatePerYear,
>             multiplierPerYear,
>             jumpMultiplierPerYear,
>             kink_
>         );
79c105,109
<     function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {
---
>     function utilizationRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) public pure returns (uint256) {
95,96c125,130
<     function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
<         uint util = utilizationRate(cash, borrows, reserves);
---
>     function getBorrowRateInternal(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) internal view returns (uint256) {
>         uint256 util = utilizationRate(cash, borrows, reserves);
101,103c135,142
<             uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
<             uint excessUtil = util.sub(kink);
<             return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
---
>             uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(
>                 baseRatePerBlock
>             );
>             uint256 excessUtil = util.sub(kink);
>             return
>                 excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(
>                     normalRate
>                 );
115,119c154,166
<     function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {
<         uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);
<         uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
<         uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
<         return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
---
>     function getSupplyRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves,
>         uint256 reserveFactorMantissa
>     ) public view returns (uint256) {
>         uint256 oneMinusReserveFactor = uint256(1e18).sub(
>             reserveFactorMantissa
>         );
>         uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);
>         uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
>         return
>             utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
129c176,181
<     function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {
---
>     function updateJumpRateModelInternal(
>         uint256 baseRatePerYear,
>         uint256 multiplierPerYear,
>         uint256 jumpMultiplierPerYear,
>         uint256 kink_
>     ) internal {
131c183,185
<         multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(blocksPerYear.mul(kink_));
---
>         multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(
>             blocksPerYear.mul(kink_)
>         );
135c189,194
<         emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);
---
>         emit NewInterestParams(
>             baseRatePerBlock,
>             multiplierPerBlock,
>             jumpMultiplierPerBlock,
>             kink
>         );
diff -x .git -r ../compound-protocol/contracts/CarefulMath.sol src/core/CarefulMath.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
4,8c4,8
<   * @title Careful Math
<   * @author Compound
<   * @notice Derived from OpenZeppelin's SafeMath library
<   *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol
<   */
---
>  * @title Careful Math
>  * @author Compound
>  * @notice Derived from OpenZeppelin's SafeMath library
>  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol
>  */
10d9
< 
22,24c21,27
<     * @dev Multiplies two numbers, returns an error on overflow.
<     */
<     function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {
---
>      * @dev Multiplies two numbers, returns an error on overflow.
>      */
>     function mulUInt(uint256 a, uint256 b)
>         internal
>         pure
>         returns (MathError, uint256)
>     {
29c32
<         uint c = a * b;
---
>         uint256 c = a * b;
39,41c42,48
<     * @dev Integer division of two numbers, truncating the quotient.
<     */
<     function divUInt(uint a, uint b) internal pure returns (MathError, uint) {
---
>      * @dev Integer division of two numbers, truncating the quotient.
>      */
>     function divUInt(uint256 a, uint256 b)
>         internal
>         pure
>         returns (MathError, uint256)
>     {
50,52c57,63
<     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).
<     */
<     function subUInt(uint a, uint b) internal pure returns (MathError, uint) {
---
>      * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).
>      */
>     function subUInt(uint256 a, uint256 b)
>         internal
>         pure
>         returns (MathError, uint256)
>     {
61,64c72,79
<     * @dev Adds two numbers, returns an error on overflow.
<     */
<     function addUInt(uint a, uint b) internal pure returns (MathError, uint) {
<         uint c = a + b;
---
>      * @dev Adds two numbers, returns an error on overflow.
>      */
>     function addUInt(uint256 a, uint256 b)
>         internal
>         pure
>         returns (MathError, uint256)
>     {
>         uint256 c = a + b;
74,77c89,96
<     * @dev add a and b and then subtract c
<     */
<     function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {
<         (MathError err0, uint sum) = addUInt(a, b);
---
>      * @dev add a and b and then subtract c
>      */
>     function addThenSubUInt(
>         uint256 a,
>         uint256 b,
>         uint256 c
>     ) internal pure returns (MathError, uint256) {
>         (MathError err0, uint256 sum) = addUInt(a, b);
85c104
< }
\ No newline at end of file
---
> }
diff -x .git -r ../compound-protocol/contracts/CDaiDelegate.sol src/core/CDaiDelegate.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
30,33c30,40
<     function _becomeImplementation(bytes memory data) public {
<         require(msg.sender == admin, "only the admin may initialize the implementation");
< 
<         (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));
---
>     function _becomeImplementation(bytes calldata data) external {
>         require(
>             msg.sender == address(this) || hasAdminRights(),
>             "only self or admin may call _becomeImplementation"
>         );
> 
>         // Decode data
>         (address daiJoinAddress_, address potAddress_) = abi.decode(
>             data,
>             (address, address)
>         );
42c49,51
<     function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {
---
>     function _becomeImplementation(address daiJoinAddress_, address potAddress_)
>         internal
>     {
48c57,60
<         require(address(dai) == underlying, "DAI must be the same as underlying");
---
>         require(
>             address(dai) == underlying,
>             "DAI must be the same as underlying"
>         );
56c68
<         dai.approve(daiJoinAddress, uint(-1));
---
>         dai.approve(daiJoinAddress, uint256(-1));
72,74c84
<     function _resignImplementation() public {
<         require(msg.sender == admin, "only the admin may abandon the implementation");
< 
---
>     function _resignImplementation() internal {
84c94
<         uint pie = pot.pie(address(this));
---
>         uint256 pie = pot.pie(address(this));
88c98
<         uint bal = vat.dai(address(this));
---
>         uint256 bal = vat.dai(address(this));
97,101c107,111
<       * @notice Accrues DSR then applies accrued interest to total borrows and reserves
<       * @dev This calculates interest accrued from the last checkpointed block
<       *      up to the current block and writes new checkpoint to storage.
<       */
<     function accrueInterest() public returns (uint) {
---
>      * @notice Accrues DSR then applies accrued interest to total borrows and reserves
>      * @dev This calculates interest accrued from the last checkpointed block
>      *      up to the current block and writes new checkpoint to storage.
>      */
>     function accrueInterest() public returns (uint256) {
116c126
<     function getCashPrior() internal view returns (uint) {
---
>     function getCashPrior() internal view returns (uint256) {
118c128
<         uint pie = pot.pie(address(this));
---
>         uint256 pie = pot.pie(address(this));
128c138,141
<     function doTransferIn(address from, uint amount) internal returns (uint) {
---
>     function doTransferIn(address from, uint256 amount)
>         internal
>         returns (uint256)
>     {
131c144,147
<         require(token.transferFrom(from, address(this), amount), "unexpected EIP-20 transfer in return");
---
>         require(
>             token.transferFrom(from, address(this), amount),
>             "unexpected EIP-20 transfer in return"
>         );
142c158
<         uint bal = vat.dai(address(this));
---
>         uint256 bal = vat.dai(address(this));
146c162
<         uint pie = bal / pot.chi();
---
>         uint256 pie = bal / pot.chi();
157c173
<     function doTransferOut(address payable to, uint amount) internal {
---
>     function doTransferOut(address payable to, uint256 amount) internal {
163c179
<         uint pie = add(mul(amount, RAY) / pot.chi(), 1);
---
>         uint256 pie = add(mul(amount, RAY) / pot.chi(), 1);
171c187
<     uint256 constant RAY = 10 ** 27;
---
>     uint256 constant RAY = 10**27;
173c189
<     function add(uint x, uint y) internal pure returns (uint z) {
---
>     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
177c193
<     function mul(uint x, uint y) internal pure returns (uint z) {
---
>     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
185,189c201,209
<     function chi() external view returns (uint);
<     function pie(address) external view returns (uint);
<     function drip() external returns (uint);
<     function join(uint) external;
<     function exit(uint) external;
---
>     function chi() external view returns (uint256);
> 
>     function pie(address) external view returns (uint256);
> 
>     function drip() external returns (uint256);
> 
>     function join(uint256) external;
> 
>     function exit(uint256) external;
193,195c213,221
<     function approve(address, uint) external;
<     function balanceOf(address) external view returns (uint);
<     function transferFrom(address, address, uint) external returns (bool);
---
>     function approve(address, uint256) external;
> 
>     function balanceOf(address) external view returns (uint256);
> 
>     function transferFrom(
>         address,
>         address,
>         uint256
>     ) external returns (bool);
199c225,226
<     function dai(address) external view returns (uint);
---
>     function dai(address) external view returns (uint256);
> 
204a232
> 
206,207c234,237
<     function join(address, uint) external payable;
<     function exit(address, uint) external;
---
> 
>     function join(address, uint256) external payable;
> 
>     function exit(address, uint256) external;
diff -x .git -r ../compound-protocol/contracts/CErc20Delegate.sol src/core/CErc20Delegate.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
10c10
< contract CErc20Delegate is CErc20, CDelegateInterface {
---
> contract CErc20Delegate is CDelegateInterface, CErc20 {
20c20
<     function _becomeImplementation(bytes memory data) public {
---
>     function _becomeImplementation(bytes calldata data) external {
29c29,34
<         require(msg.sender == admin, "only the admin may call _becomeImplementation");
---
>         require(msg.sender == address(this) || hasAdminRights(), "!self");
> 
>         // Make sure admin storage is set up correctly
>         __admin = address(0);
>         __adminHasRights = false;
>         __fuseAdminHasRights = false;
35c40
<     function _resignImplementation() public {
---
>     function _resignImplementation() internal {
39a45,89
>     }
> 
>     /**
>      * @dev Internal function to update the implementation of the delegator
>      * @param implementation_ The address of the new implementation for delegation
>      * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
>      * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
>      */
>     function _setImplementationInternal(
>         address implementation_,
>         bool allowResign,
>         bytes memory becomeImplementationData
>     ) internal {
>         // Check whitelist
>         require(
>             fuseAdmin.cErc20DelegateWhitelist(
>                 implementation,
>                 implementation_,
>                 allowResign
>             ),
>             "!impl"
>         );
> 
>         // Call _resignImplementation internally (this delegate's code)
>         if (allowResign) _resignImplementation();
> 
>         // Get old implementation
>         address oldImplementation = implementation;
> 
>         // Store new implementation
>         implementation = implementation_;
> 
>         // Call _becomeImplementation externally (delegating to new delegate's code)
>         _functionCall(
>             address(this),
>             abi.encodeWithSignature(
>                 "_becomeImplementation(bytes)",
>                 becomeImplementationData
>             ),
>             "!become"
>         );
> 
>         // Emit event
>         emit NewImplementation(oldImplementation, implementation);
>     }
41c91,133
<         require(msg.sender == admin, "only the admin may call _resignImplementation");
---
>     /**
>      * @notice Called by the admin to update the implementation of the delegator
>      * @param implementation_ The address of the new implementation for delegation
>      * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
>      * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
>      */
>     function _setImplementationSafe(
>         address implementation_,
>         bool allowResign,
>         bytes calldata becomeImplementationData
>     ) external {
>         // Check admin rights
>         require(hasAdminRights(), "!admin");
> 
>         // Set implementation
>         _setImplementationInternal(
>             implementation_,
>             allowResign,
>             becomeImplementationData
>         );
>     }
> 
>     /**
>      * @notice Function called before all delegator functions
>      * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary
>      */
>     function _prepare() external payable {
>         if (
>             msg.sender != address(this) &&
>             ComptrollerV3Storage(address(comptroller)).autoImplementation()
>         ) {
>             (
>                 address latestCErc20Delegate,
>                 bool allowResign,
>                 bytes memory becomeImplementationData
>             ) = fuseAdmin.latestCErc20Delegate(implementation);
>             if (implementation != latestCErc20Delegate)
>                 _setImplementationInternal(
>                     latestCErc20Delegate,
>                     allowResign,
>                     becomeImplementationData
>                 );
>         }
diff -x .git -r ../compound-protocol/contracts/CErc20Delegator.sol src/core/CErc20Delegator.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
3a4
> import "./ComptrollerStorage.sol";
10c11
< contract CErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface {
---
> contract CErc20Delegator is CDelegationStorage {
16d16
<      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
19,20d18
<      * @param decimals_ ERC-20 decimal precision of this token
<      * @param admin_ Address of the administrator of this token
24,36c22,32
<     constructor(address underlying_,
<                 ComptrollerInterface comptroller_,
<                 InterestRateModel interestRateModel_,
<                 uint initialExchangeRateMantissa_,
<                 string memory name_,
<                 string memory symbol_,
<                 uint8 decimals_,
<                 address payable admin_,
<                 address implementation_,
<                 bytes memory becomeImplementationData) public {
<         // Creator of the contract is admin during initialization
<         admin = msg.sender;
< 
---
>     constructor(
>         address underlying_,
>         ComptrollerInterface comptroller_,
>         InterestRateModel interestRateModel_,
>         string memory name_,
>         string memory symbol_,
>         address implementation_,
>         bytes memory becomeImplementationData,
>         uint256 reserveFactorMantissa_,
>         uint256 adminFeeMantissa_
>     ) public {
38,45c34,46
<         delegateTo(implementation_, abi.encodeWithSignature("initialize(address,address,address,uint256,string,string,uint8)",
<                                                             underlying_,
<                                                             comptroller_,
<                                                             interestRateModel_,
<                                                             initialExchangeRateMantissa_,
<                                                             name_,
<                                                             symbol_,
<                                                             decimals_));
---
>         delegateTo(
>             implementation_,
>             abi.encodeWithSignature(
>                 "initialize(address,address,address,string,string,uint256,uint256)",
>                 underlying_,
>                 comptroller_,
>                 interestRateModel_,
>                 name_,
>                 symbol_,
>                 reserveFactorMantissa_,
>                 adminFeeMantissa_
>             )
>         );
48,410c49,57
<         _setImplementation(implementation_, false, becomeImplementationData);
< 
<         // Set the proper admin now that initialization is done
<         admin = admin_;
<     }
< 
<     /**
<      * @notice Called by the admin to update the implementation of the delegator
<      * @param implementation_ The address of the new implementation for delegation
<      * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
<      * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
<      */
<     function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {
<         require(msg.sender == admin, "CErc20Delegator::_setImplementation: Caller must be admin");
< 
<         if (allowResign) {
<             delegateToImplementation(abi.encodeWithSignature("_resignImplementation()"));
<         }
< 
<         address oldImplementation = implementation;
<         implementation = implementation_;
< 
<         delegateToImplementation(abi.encodeWithSignature("_becomeImplementation(bytes)", becomeImplementationData));
< 
<         emit NewImplementation(oldImplementation, implementation);
<     }
< 
<     /**
<      * @notice Sender supplies assets into the market and receives cTokens in exchange
<      * @dev Accrues interest whether or not the operation succeeds, unless reverted
<      * @param mintAmount The amount of the underlying asset to supply
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function mint(uint mintAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("mint(uint256)", mintAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Sender redeems cTokens in exchange for the underlying asset
<      * @dev Accrues interest whether or not the operation succeeds, unless reverted
<      * @param redeemTokens The number of cTokens to redeem into underlying
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function redeem(uint redeemTokens) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("redeem(uint256)", redeemTokens));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
<      * @dev Accrues interest whether or not the operation succeeds, unless reverted
<      * @param redeemAmount The amount of underlying to redeem
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function redeemUnderlying(uint redeemAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("redeemUnderlying(uint256)", redeemAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<       * @notice Sender borrows assets from the protocol to their own address
<       * @param borrowAmount The amount of the underlying asset to borrow
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function borrow(uint borrowAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("borrow(uint256)", borrowAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Sender repays their own borrow
<      * @param repayAmount The amount to repay
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function repayBorrow(uint repayAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("repayBorrow(uint256)", repayAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Sender repays a borrow belonging to borrower
<      * @param borrower the account with the debt being payed off
<      * @param repayAmount The amount to repay
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("repayBorrowBehalf(address,uint256)", borrower, repayAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice The sender liquidates the borrowers collateral.
<      *  The collateral seized is transferred to the liquidator.
<      * @param borrower The borrower of this cToken to be liquidated
<      * @param cTokenCollateral The market in which to seize collateral from the borrower
<      * @param repayAmount The amount of the underlying borrowed asset to repay
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("liquidateBorrow(address,uint256,address)", borrower, repayAmount, cTokenCollateral));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Transfer `amount` tokens from `msg.sender` to `dst`
<      * @param dst The address of the destination account
<      * @param amount The number of tokens to transfer
<      * @return Whether or not the transfer succeeded
<      */
<     function transfer(address dst, uint amount) external returns (bool) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("transfer(address,uint256)", dst, amount));
<         return abi.decode(data, (bool));
<     }
< 
<     /**
<      * @notice Transfer `amount` tokens from `src` to `dst`
<      * @param src The address of the source account
<      * @param dst The address of the destination account
<      * @param amount The number of tokens to transfer
<      * @return Whether or not the transfer succeeded
<      */
<     function transferFrom(address src, address dst, uint256 amount) external returns (bool) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("transferFrom(address,address,uint256)", src, dst, amount));
<         return abi.decode(data, (bool));
<     }
< 
<     /**
<      * @notice Approve `spender` to transfer up to `amount` from `src`
<      * @dev This will overwrite the approval amount for `spender`
<      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
<      * @param spender The address of the account which may transfer tokens
<      * @param amount The number of tokens that are approved (-1 means infinite)
<      * @return Whether or not the approval succeeded
<      */
<     function approve(address spender, uint256 amount) external returns (bool) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("approve(address,uint256)", spender, amount));
<         return abi.decode(data, (bool));
<     }
< 
<     /**
<      * @notice Get the current allowance from `owner` for `spender`
<      * @param owner The address of the account which owns the tokens to be spent
<      * @param spender The address of the account which may transfer tokens
<      * @return The number of tokens allowed to be spent (-1 means infinite)
<      */
<     function allowance(address owner, address spender) external view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("allowance(address,address)", owner, spender));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Get the token balance of the `owner`
<      * @param owner The address of the account to query
<      * @return The number of tokens owned by `owner`
<      */
<     function balanceOf(address owner) external view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("balanceOf(address)", owner));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Get the underlying balance of the `owner`
<      * @dev This also accrues interest in a transaction
<      * @param owner The address of the account to query
<      * @return The amount of underlying owned by `owner`
<      */
<     function balanceOfUnderlying(address owner) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("balanceOfUnderlying(address)", owner));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Get a snapshot of the account's balances, and the cached exchange rate
<      * @dev This is used by comptroller to more efficiently perform liquidity checks.
<      * @param account Address of the account to snapshot
<      * @return (possible error, token balance, borrow balance, exchange rate mantissa)
<      */
<     function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("getAccountSnapshot(address)", account));
<         return abi.decode(data, (uint, uint, uint, uint));
<     }
< 
<     /**
<      * @notice Returns the current per-block borrow interest rate for this cToken
<      * @return The borrow interest rate per block, scaled by 1e18
<      */
<     function borrowRatePerBlock() external view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("borrowRatePerBlock()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Returns the current per-block supply interest rate for this cToken
<      * @return The supply interest rate per block, scaled by 1e18
<      */
<     function supplyRatePerBlock() external view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("supplyRatePerBlock()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Returns the current total borrows plus accrued interest
<      * @return The total borrows with interest
<      */
<     function totalBorrowsCurrent() external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("totalBorrowsCurrent()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
<      * @param account The address whose balance should be calculated after updating borrowIndex
<      * @return The calculated balance
<      */
<     function borrowBalanceCurrent(address account) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("borrowBalanceCurrent(address)", account));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Return the borrow balance of account based on stored data
<      * @param account The address whose balance should be calculated
<      * @return The calculated balance
<      */
<     function borrowBalanceStored(address account) public view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("borrowBalanceStored(address)", account));
<         return abi.decode(data, (uint));
<     }
< 
<    /**
<      * @notice Accrue interest then return the up-to-date exchange rate
<      * @return Calculated exchange rate scaled by 1e18
<      */
<     function exchangeRateCurrent() public returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("exchangeRateCurrent()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Calculates the exchange rate from the underlying to the CToken
<      * @dev This function does not accrue interest before calculating the exchange rate
<      * @return Calculated exchange rate scaled by 1e18
<      */
<     function exchangeRateStored() public view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("exchangeRateStored()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Get cash balance of this cToken in the underlying asset
<      * @return The quantity of underlying asset owned by this contract
<      */
<     function getCash() external view returns (uint) {
<         bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("getCash()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<       * @notice Applies accrued interest to total borrows and reserves.
<       * @dev This calculates interest accrued from the last checkpointed block
<       *      up to the current block and writes new checkpoint to storage.
<       */
<     function accrueInterest() public returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("accrueInterest()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Transfers collateral tokens (this market) to the liquidator.
<      * @dev Will fail unless called by another cToken during the process of liquidation.
<      *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
<      * @param liquidator The account receiving seized collateral
<      * @param borrower The account having collateral seized
<      * @param seizeTokens The number of cTokens to seize
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("seize(address,address,uint256)", liquidator, borrower, seizeTokens));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)
<      * @param token The address of the ERC-20 token to sweep
<      */
<     function sweepToken(EIP20NonStandardInterface token) external {
<         delegateToImplementation(abi.encodeWithSignature("sweepToken(address)", token));
<     }
< 
< 
<     /*** Admin Functions ***/
< 
<     /**
<       * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
<       * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
<       * @param newPendingAdmin New pending admin.
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setPendingAdmin(address)", newPendingAdmin));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<       * @notice Sets a new comptroller for the market
<       * @dev Admin function to set a new comptroller
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setComptroller(address)", newComptroller));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<       * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
<       * @dev Admin function to accrue interest and set a new reserve factor
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setReserveFactor(uint256)", newReserveFactorMantissa));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<       * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
<       * @dev Admin function for pending admin to accept role and update admin
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _acceptAdmin() external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_acceptAdmin()"));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Accrues interest and adds reserves by transferring from admin
<      * @param addAmount Amount of reserves to add
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function _addReserves(uint addAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_addReserves(uint256)", addAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Accrues interest and reduces reserves by transferring to admin
<      * @param reduceAmount Amount of reduction to reserves
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function _reduceReserves(uint reduceAmount) external returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_reduceReserves(uint256)", reduceAmount));
<         return abi.decode(data, (uint));
<     }
< 
<     /**
<      * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh
<      * @dev Admin function to accrue interest and update the interest rate model
<      * @param newInterestRateModel the new interest rate model to use
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
<         bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setInterestRateModel(address)", newInterestRateModel));
<         return abi.decode(data, (uint));
---
>         delegateTo(
>             implementation_,
>             abi.encodeWithSignature(
>                 "_setImplementationSafe(address,bool,bytes)",
>                 implementation_,
>                 false,
>                 becomeImplementationData
>             )
>         );
420c67,70
<     function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {
---
>     function delegateTo(address callee, bytes memory data)
>         internal
>         returns (bytes memory)
>     {
431,440d80
<      * @notice Delegates execution to the implementation contract
<      * @dev It returns to the external caller whatever the implementation returns or forwards reverts
<      * @param data The raw data to delegatecall
<      * @return The returned bytes from the delegatecall
<      */
<     function delegateToImplementation(bytes memory data) public returns (bytes memory) {
<         return delegateTo(implementation, data);
<     }
< 
<     /**
443,445d82
<      *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.
<      * @param data The raw data to delegatecall
<      * @return The returned bytes from the delegatecall
447,455c84,89
<     function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {
<         (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", data));
<         assembly {
<             if eq(success, 0) {
<                 revert(add(returnData, 0x20), returndatasize)
<             }
<         }
<         return abi.decode(returnData, (bytes));
<     }
---
>     function() external payable {
>         // Cannot send value to CErc20Delegator
>         require(
>             msg.value == 0,
>             "CErc20Delegator:fallback: cannot send value to fallback"
>         );
457,462c91,92
<     /**
<      * @notice Delegates execution to an implementation contract
<      * @dev It returns to the external caller whatever the implementation returns or forwards reverts
<      */
<     function () external payable {
<         require(msg.value == 0,"CErc20Delegator:fallback: cannot send value to fallback");
---
>         // Check for automatic implementation
>         delegateTo(implementation, abi.encodeWithSignature("_prepare()"));
472,473c102,107
<             case 0 { revert(free_mem_ptr, returndatasize) }
<             default { return(free_mem_ptr, returndatasize) }
---
>             case 0 {
>                 revert(free_mem_ptr, returndatasize)
>             }
>             default {
>                 return(free_mem_ptr, returndatasize)
>             }
Only in ../compound-protocol/contracts/: CErc20Immutable.sol
diff -x .git -r ../compound-protocol/contracts/CErc20.sol src/core/CErc20.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
6c6
<   function delegate(address delegatee) external;
---
>     function delegate(address delegatee) external;
11a12
>  * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).
20d20
<      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
23d22
<      * @param decimals_ ERC-20 decimal precision of this token
25,31c24,32
<     function initialize(address underlying_,
<                         ComptrollerInterface comptroller_,
<                         InterestRateModel interestRateModel_,
<                         uint initialExchangeRateMantissa_,
<                         string memory name_,
<                         string memory symbol_,
<                         uint8 decimals_) public {
---
>     function initialize(
>         address underlying_,
>         ComptrollerInterface comptroller_,
>         InterestRateModel interestRateModel_,
>         string memory name_,
>         string memory symbol_,
>         uint256 reserveFactorMantissa_,
>         uint256 adminFeeMantissa_
>     ) public {
33c34,45
<         super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);
---
>         uint256 initialExchangeRateMantissa_ = 0.2e18;
>         uint8 decimals_ = EIP20Interface(underlying_).decimals();
>         super.initialize(
>             comptroller_,
>             interestRateModel_,
>             initialExchangeRateMantissa_,
>             name_,
>             symbol_,
>             decimals_,
>             reserveFactorMantissa_,
>             adminFeeMantissa_
>         );
48,49c60,61
<     function mint(uint mintAmount) external returns (uint) {
<         (uint err,) = mintInternal(mintAmount);
---
>     function mint(uint256 mintAmount) external returns (uint256) {
>         (uint256 err, ) = mintInternal(mintAmount);
59c71
<     function redeem(uint redeemTokens) external returns (uint) {
---
>     function redeem(uint256 redeemTokens) external returns (uint256) {
69c81
<     function redeemUnderlying(uint redeemAmount) external returns (uint) {
---
>     function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {
74,78c86,90
<       * @notice Sender borrows assets from the protocol to their own address
<       * @param borrowAmount The amount of the underlying asset to borrow
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function borrow(uint borrowAmount) external returns (uint) {
---
>      * @notice Sender borrows assets from the protocol to their own address
>      * @param borrowAmount The amount of the underlying asset to borrow
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function borrow(uint256 borrowAmount) external returns (uint256) {
87,88c99,100
<     function repayBorrow(uint repayAmount) external returns (uint) {
<         (uint err,) = repayBorrowInternal(repayAmount);
---
>     function repayBorrow(uint256 repayAmount) external returns (uint256) {
>         (uint256 err, ) = repayBorrowInternal(repayAmount);
98,99c110,114
<     function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {
<         (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);
---
>     function repayBorrowBehalf(address borrower, uint256 repayAmount)
>         external
>         returns (uint256)
>     {
>         (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);
111,112c126,135
<     function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {
<         (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);
---
>     function liquidateBorrow(
>         address borrower,
>         uint256 repayAmount,
>         CTokenInterface cTokenCollateral
>     ) external returns (uint256) {
>         (uint256 err, ) = liquidateBorrowInternal(
>             borrower,
>             repayAmount,
>             cTokenCollateral
>         );
116,134d138
<     /**
<      * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)
<      * @param token The address of the ERC-20 token to sweep
<      */
<     function sweepToken(EIP20NonStandardInterface token) external {
<     	require(address(token) != underlying, "CErc20::sweepToken: can not sweep underlying token");
<     	uint256 balance = token.balanceOf(address(this));
<     	token.transfer(admin, balance);
<     }
< 
<     /**
<      * @notice The sender adds to reserves.
<      * @param addAmount The amount fo underlying token to add as reserves
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function _addReserves(uint addAmount) external returns (uint) {
<         return _addReservesInternal(addAmount);
<     }
< 
142c146
<     function getCashPrior() internal view returns (uint) {
---
>     function getCashPrior() internal view returns (uint256) {
156,175c160,175
<     function doTransferIn(address from, uint amount) internal returns (uint) {
<         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);
<         uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));
<         token.transferFrom(from, address(this), amount);
< 
<         bool success;
<         assembly {
<             switch returndatasize()
<                 case 0 {                       // This is a non-standard ERC-20
<                     success := not(0)          // set success to true
<                 }
<                 case 32 {                      // This is a compliant ERC-20
<                     returndatacopy(0, 0, 32)
<                     success := mload(0)        // Set `success = returndata` of external call
<                 }
<                 default {                      // This is an excessively non-compliant ERC-20, revert.
<                     revert(0, 0)
<                 }
<         }
<         require(success, "TOKEN_TRANSFER_IN_FAILED");
---
>     function doTransferIn(address from, uint256 amount)
>         internal
>         returns (uint256)
>     {
>         uint256 balanceBefore = EIP20Interface(underlying).balanceOf(
>             address(this)
>         );
>         _callOptionalReturn(
>             abi.encodeWithSelector(
>                 EIP20NonStandardInterface(underlying).transferFrom.selector,
>                 from,
>                 address(this),
>                 amount
>             ),
>             "TOKEN_TRANSFER_IN_FAILED"
>         );
178c178,180
<         uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));
---
>         uint256 balanceAfter = EIP20Interface(underlying).balanceOf(
>             address(this)
>         );
180c182
<         return balanceAfter - balanceBefore;   // underflow already checked above, just subtract
---
>         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
192,210c194,202
<     function doTransferOut(address payable to, uint amount) internal {
<         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);
<         token.transfer(to, amount);
< 
<         bool success;
<         assembly {
<             switch returndatasize()
<                 case 0 {                      // This is a non-standard ERC-20
<                     success := not(0)          // set success to true
<                 }
<                 case 32 {                     // This is a compliant ERC-20
<                     returndatacopy(0, 0, 32)
<                     success := mload(0)        // Set `success = returndata` of external call
<                 }
<                 default {                     // This is an excessively non-compliant ERC-20, revert.
<                     revert(0, 0)
<                 }
<         }
<         require(success, "TOKEN_TRANSFER_OUT_FAILED");
---
>     function doTransferOut(address payable to, uint256 amount) internal {
>         _callOptionalReturn(
>             abi.encodeWithSelector(
>                 EIP20NonStandardInterface(underlying).transfer.selector,
>                 to,
>                 amount
>             ),
>             "TOKEN_TRANSFER_OUT_FAILED"
>         );
214,217c206,223
<     * @notice Admin call to delegate the votes of the COMP-like underlying
<     * @param compLikeDelegatee The address to delegate votes to
<     * @dev CTokens whose underlying are not CompLike should revert here
<     */
---
>      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
>      * on the return value: the return value is optional (but if data is returned, it must not be false).
>      * @param data The call data (encoded using abi.encode or one of its variants).
>      * @param errorMessage The revert string to return on failure.
>      */
>     function _callOptionalReturn(bytes memory data, string memory errorMessage)
>         internal
>     {
>         bytes memory returndata = _functionCall(underlying, data, errorMessage);
>         if (returndata.length > 0)
>             require(abi.decode(returndata, (bool)), errorMessage);
>     }
> 
>     /**
>      * @notice Admin call to delegate the votes of the COMP-like underlying
>      * @param compLikeDelegatee The address to delegate votes to
>      * @dev CTokens whose underlying are not CompLike should revert here
>      */
219c225,228
<         require(msg.sender == admin, "only the admin may set the comp-like delegate");
---
>         require(
>             hasAdminRights(),
>             "only the admin may set the comp-like delegate"
>         );
Only in src/core/: CEtherDelegate.sol
Only in src/core/: CEtherDelegator.sol
diff -x .git -r ../compound-protocol/contracts/CEther.sol src/core/CEther.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
7a8
>  * @dev This contract should not to be deployed on its own; instead, deploy `CEtherDelegator` (proxy contract) and `CEtherDelegate` (logic/implementation contract).
10c11
< contract CEther is CToken {
---
> contract CEther is CToken, CEtherInterface {
12c13
<      * @notice Construct a new CEther money market
---
>      * @notice Initialize the new money market
15d15
<      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
18,19d17
<      * @param decimals_ ERC-20 decimal precision of this token
<      * @param admin_ Address of the administrator of this token
21,34c19,39
<     constructor(ComptrollerInterface comptroller_,
<                 InterestRateModel interestRateModel_,
<                 uint initialExchangeRateMantissa_,
<                 string memory name_,
<                 string memory symbol_,
<                 uint8 decimals_,
<                 address payable admin_) public {
<         // Creator of the contract is admin during initialization
<         admin = msg.sender;
< 
<         initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);
< 
<         // Set the proper admin now that initialization is done
<         admin = admin_;
---
>     function initialize(
>         ComptrollerInterface comptroller_,
>         InterestRateModel interestRateModel_,
>         string memory name_,
>         string memory symbol_,
>         uint256 reserveFactorMantissa_,
>         uint256 adminFeeMantissa_
>     ) public {
>         // CToken initialize does the bulk of the work
>         uint256 initialExchangeRateMantissa_ = 0.2e18;
>         uint8 decimals_ = 18;
>         super.initialize(
>             comptroller_,
>             interestRateModel_,
>             initialExchangeRateMantissa_,
>             name_,
>             symbol_,
>             decimals_,
>             reserveFactorMantissa_,
>             adminFeeMantissa_
>         );
37d41
< 
45c49
<         (uint err,) = mintInternal(msg.value);
---
>         (uint256 err, ) = mintInternal(msg.value);
55c59
<     function redeem(uint redeemTokens) external returns (uint) {
---
>     function redeem(uint256 redeemTokens) external returns (uint256) {
65c69
<     function redeemUnderlying(uint redeemAmount) external returns (uint) {
---
>     function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {
70,74c74,78
<       * @notice Sender borrows assets from the protocol to their own address
<       * @param borrowAmount The amount of the underlying asset to borrow
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function borrow(uint borrowAmount) external returns (uint) {
---
>      * @notice Sender borrows assets from the protocol to their own address
>      * @param borrowAmount The amount of the underlying asset to borrow
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function borrow(uint256 borrowAmount) external returns (uint256) {
83c87
<         (uint err,) = repayBorrowInternal(msg.value);
---
>         (uint256 err, ) = repayBorrowInternal(msg.value);
93c97
<         (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);
---
>         (uint256 err, ) = repayBorrowBehalfInternal(borrower, msg.value);
104,105c108,116
<     function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {
<         (uint err,) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);
---
>     function liquidateBorrow(address borrower, CToken cTokenCollateral)
>         external
>         payable
>     {
>         (uint256 err, ) = liquidateBorrowInternal(
>             borrower,
>             msg.value,
>             cTokenCollateral
>         );
110,117d120
<      * @notice The sender adds to reserves.
<      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<      */
<     function _addReserves() external payable returns (uint) {
<         return _addReservesInternal(msg.value);
<     }
< 
<     /**
120,121c123,124
<     function () external payable {
<         (uint err,) = mintInternal(msg.value);
---
>     function() external payable {
>         (uint256 err, ) = mintInternal(msg.value);
132,133c135,139
<     function getCashPrior() internal view returns (uint) {
<         (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);
---
>     function getCashPrior() internal view returns (uint256) {
>         (MathError err, uint256 startingBalance) = subUInt(
>             address(this).balance,
>             msg.value
>         );
144c150,153
<     function doTransferIn(address from, uint amount) internal returns (uint) {
---
>     function doTransferIn(address from, uint256 amount)
>         internal
>         returns (uint256)
>     {
151,153c160,163
<     function doTransferOut(address payable to, uint amount) internal {
<         /* Send the Ether, with minimal gas and revert on failure */
<         to.transfer(amount);
---
>     function doTransferOut(address payable to, uint256 amount) internal {
>         // Send the Ether and revert on failure
>         (bool success, ) = to.call.value(amount)("");
>         require(success, "doTransferOut failed");
156,157c166,170
<     function requireNoError(uint errCode, string memory message) internal pure {
<         if (errCode == uint(Error.NO_ERROR)) {
---
>     function requireNoError(uint256 errCode, string memory message)
>         internal
>         pure
>     {
>         if (errCode == uint256(Error.NO_ERROR)) {
161,162c174,175
<         bytes memory fullMessage = new bytes(bytes(message).length + 5);
<         uint i;
---
>         bytes memory fullMessage = new bytes(bytes(message).length + 7);
>         uint256 i;
168,172c181,187
<         fullMessage[i+0] = byte(uint8(32));
<         fullMessage[i+1] = byte(uint8(40));
<         fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));
<         fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));
<         fullMessage[i+4] = byte(uint8(41));
---
>         fullMessage[i + 0] = bytes1(uint8(32));
>         fullMessage[i + 1] = bytes1(uint8(40));
>         fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 1000)));
>         fullMessage[i + 3] = bytes1(uint8(48 + ((errCode / 100) % 10)));
>         fullMessage[i + 4] = bytes1(uint8(48 + ((errCode / 10) % 10)));
>         fullMessage[i + 5] = bytes1(uint8(48 + (errCode % 10)));
>         fullMessage[i + 6] = bytes1(uint8(41));
174c189
<         require(errCode == uint(Error.NO_ERROR), string(fullMessage));
---
>         require(errCode == uint256(Error.NO_ERROR), string(fullMessage));
diff -x .git -r ../compound-protocol/contracts/ComptrollerG1.sol src/core/ComptrollerG1.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
17c17,22
< contract ComptrollerG1 is ComptrollerV1Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {
---
> contract ComptrollerG1 is
>     ComptrollerV1Storage,
>     ComptrollerInterface,
>     ComptrollerErrorReporter,
>     Exponential
> {
23d27
< 
29,30c33
<         uint collateralFactorMantissa;
< 
---
>         uint256 collateralFactorMantissa;
61c64,67
<     event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);
---
>     event NewCloseFactor(
>         uint256 oldCloseFactorMantissa,
>         uint256 newCloseFactorMantissa
>     );
66c72,76
<     event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);
---
>     event NewCollateralFactor(
>         CToken cToken,
>         uint256 oldCollateralFactorMantissa,
>         uint256 newCollateralFactorMantissa
>     );
71c81,84
<     event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);
---
>     event NewLiquidationIncentive(
>         uint256 oldLiquidationIncentiveMantissa,
>         uint256 newLiquidationIncentiveMantissa
>     );
76c89
<     event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);
---
>     event NewMaxAssets(uint256 oldMaxAssets, uint256 newMaxAssets);
81c94,97
<     event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);
---
>     event NewPriceOracle(
>         PriceOracle oldPriceOracle,
>         PriceOracle newPriceOracle
>     );
84c100
<     uint constant closeFactorMinMantissa = 5e16; // 0.05
---
>     uint256 constant closeFactorMinMantissa = 5e16; // 0.05
87c103
<     uint constant closeFactorMaxMantissa = 9e17; // 0.9
---
>     uint256 constant closeFactorMaxMantissa = 9e17; // 0.9
90c106
<     uint constant collateralFactorMaxMantissa = 9e17; // 0.9
---
>     uint256 constant collateralFactorMaxMantissa = 9e17; // 0.9
93c109
<     uint constant liquidationIncentiveMinMantissa = mantissaOne;
---
>     uint256 constant liquidationIncentiveMinMantissa = mantissaOne;
96c112
<     uint constant liquidationIncentiveMaxMantissa = 15e17; // 1.5
---
>     uint256 constant liquidationIncentiveMaxMantissa = 15e17; // 1.5
109c125,129
<     function getAssetsIn(address account) external view returns (CToken[] memory) {
---
>     function getAssetsIn(address account)
>         external
>         view
>         returns (CToken[] memory)
>     {
121c141,145
<     function checkMembership(address account, CToken cToken) external view returns (bool) {
---
>     function checkMembership(address account, CToken cToken)
>         external
>         view
>         returns (bool)
>     {
130,131c154,158
<     function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {
<         uint len = cTokens.length;
---
>     function enterMarkets(address[] memory cTokens)
>         public
>         returns (uint256[] memory)
>     {
>         uint256 len = cTokens.length;
133,134c160,161
<         uint[] memory results = new uint[](len);
<         for (uint i = 0; i < len; i++) {
---
>         uint256[] memory results = new uint256[](len);
>         for (uint256 i = 0; i < len; i++) {
140c167
<                 results[i] = uint(Error.MARKET_NOT_LISTED);
---
>                 results[i] = uint256(Error.MARKET_NOT_LISTED);
146c173
<                 results[i] = uint(Error.NO_ERROR);
---
>                 results[i] = uint256(Error.NO_ERROR);
150c177
<             if (accountAssets[msg.sender].length >= maxAssets)  {
---
>             if (accountAssets[msg.sender].length >= maxAssets) {
152c179
<                 results[i] = uint(Error.TOO_MANY_ASSETS);
---
>                 results[i] = uint256(Error.TOO_MANY_ASSETS);
166c193
<             results[i] = uint(Error.NO_ERROR);
---
>             results[i] = uint256(Error.NO_ERROR);
179c206
<     function exitMarket(address cTokenAddress) external returns (uint) {
---
>     function exitMarket(address cTokenAddress) external returns (uint256) {
182c209,210
<         (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);
---
>         (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken
>             .getAccountSnapshot(msg.sender);
187c215,219
<             return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);
---
>             return
>                 fail(
>                     Error.NONZERO_BORROW_BALANCE,
>                     FailureInfo.EXIT_MARKET_BALANCE_OWED
>                 );
191c223,227
<         uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);
---
>         uint256 allowed = redeemAllowedInternal(
>             cTokenAddress,
>             msg.sender,
>             tokensHeld
>         );
193c229,234
<             return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);
---
>             return
>                 failOpaque(
>                     Error.REJECTION,
>                     FailureInfo.EXIT_MARKET_REJECTION,
>                     allowed
>                 );
200c241
<             return uint(Error.NO_ERROR);
---
>             return uint256(Error.NO_ERROR);
209,211c250,252
<         uint len = userAssetList.length;
<         uint assetIndex = len;
<         for (uint i = 0; i < len; i++) {
---
>         uint256 len = userAssetList.length;
>         uint256 assetIndex = len;
>         for (uint256 i = 0; i < len; i++) {
228c269
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
240,242c281,287
<     function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint) {
<         minter;       // currently unused
<         mintAmount;   // currently unused
---
>     function mintAllowed(
>         address cToken,
>         address minter,
>         uint256 mintAmount
>     ) external returns (uint256) {
>         minter; // currently unused
>         mintAmount; // currently unused
245c290
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
250c295
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
260,264c305,314
<     function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external {
<         cToken;       // currently unused
<         minter;       // currently unused
<         mintAmount;   // currently unused
<         mintTokens;   // currently unused
---
>     function mintVerify(
>         address cToken,
>         address minter,
>         uint256 mintAmount,
>         uint256 mintTokens
>     ) external {
>         cToken; // currently unused
>         minter; // currently unused
>         mintAmount; // currently unused
>         mintTokens; // currently unused
278c328,332
<     function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint) {
---
>     function redeemAllowed(
>         address cToken,
>         address redeemer,
>         uint256 redeemTokens
>     ) external returns (uint256) {
282c336,340
<     function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {
---
>     function redeemAllowedInternal(
>         address cToken,
>         address redeemer,
>         uint256 redeemTokens
>     ) internal view returns (uint256) {
284c342
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
291c349
<             return uint(Error.NO_ERROR);
---
>             return uint256(Error.NO_ERROR);
295c353,362
<         (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);
---
>         (
>             Error err,
>             ,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(
>                 redeemer,
>                 CToken(cToken),
>                 redeemTokens,
>                 0
>             );
297c364
<             return uint(err);
---
>             return uint256(err);
300c367
<             return uint(Error.INSUFFICIENT_LIQUIDITY);
---
>             return uint256(Error.INSUFFICIENT_LIQUIDITY);
303c370
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
313,317c380,389
<     function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external {
<         cToken;         // currently unused
<         redeemer;       // currently unused
<         redeemAmount;   // currently unused
<         redeemTokens;   // currently unused
---
>     function redeemVerify(
>         address cToken,
>         address redeemer,
>         uint256 redeemAmount,
>         uint256 redeemTokens
>     ) external {
>         cToken; // currently unused
>         redeemer; // currently unused
>         redeemAmount; // currently unused
>         redeemTokens; // currently unused
332c404,408
<     function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {
---
>     function borrowAllowed(
>         address cToken,
>         address borrower,
>         uint256 borrowAmount
>     ) external returns (uint256) {
334c410
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
340c416
<             return uint(Error.MARKET_NOT_ENTERED);
---
>             return uint256(Error.MARKET_NOT_ENTERED);
344c420
<             return uint(Error.PRICE_ERROR);
---
>             return uint256(Error.PRICE_ERROR);
347c423,432
<         (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);
---
>         (
>             Error err,
>             ,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(
>                 borrower,
>                 CToken(cToken),
>                 0,
>                 borrowAmount
>             );
349c434
<             return uint(err);
---
>             return uint256(err);
352c437
<             return uint(Error.INSUFFICIENT_LIQUIDITY);
---
>             return uint256(Error.INSUFFICIENT_LIQUIDITY);
355c440
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
364,367c449,456
<     function borrowVerify(address cToken, address borrower, uint borrowAmount) external {
<         cToken;         // currently unused
<         borrower;       // currently unused
<         borrowAmount;   // currently unused
---
>     function borrowVerify(
>         address cToken,
>         address borrower,
>         uint256 borrowAmount
>     ) external {
>         cToken; // currently unused
>         borrower; // currently unused
>         borrowAmount; // currently unused
386,389c475,479
<         uint repayAmount) external returns (uint) {
<         payer;         // currently unused
<         borrower;      // currently unused
<         repayAmount;   // currently unused
---
>         uint256 repayAmount
>     ) external returns (uint256) {
>         payer; // currently unused
>         borrower; // currently unused
>         repayAmount; // currently unused
392c482
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
397c487
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
411,416c501,507
<         uint repayAmount,
<         uint borrowerIndex) external {
<         cToken;        // currently unused
<         payer;         // currently unused
<         borrower;      // currently unused
<         repayAmount;   // currently unused
---
>         uint256 repayAmount,
>         uint256 borrowerIndex
>     ) external {
>         cToken; // currently unused
>         payer; // currently unused
>         borrower; // currently unused
>         repayAmount; // currently unused
437,443c528,538
<         uint repayAmount) external returns (uint) {
<         liquidator;   // currently unused
<         borrower;     // currently unused
<         repayAmount;  // currently unused
< 
<         if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {
<             return uint(Error.MARKET_NOT_LISTED);
---
>         uint256 repayAmount
>     ) external returns (uint256) {
>         liquidator; // currently unused
>         borrower; // currently unused
>         repayAmount; // currently unused
> 
>         if (
>             !markets[cTokenBorrowed].isListed ||
>             !markets[cTokenCollateral].isListed
>         ) {
>             return uint256(Error.MARKET_NOT_LISTED);
449c544,546
<         (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);
---
>         (Error err, , uint256 shortfall) = getAccountLiquidityInternal(
>             borrower
>         );
451c548
<             return uint(err);
---
>             return uint256(err);
454c551
<             return uint(Error.INSUFFICIENT_SHORTFALL);
---
>             return uint256(Error.INSUFFICIENT_SHORTFALL);
458,459c555,561
<         uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);
<         (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);
---
>         uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(
>             borrower
>         );
>         (MathError mathErr, uint256 maxClose) = mulScalarTruncate(
>             Exp({mantissa: closeFactorMantissa}),
>             borrowBalance
>         );
461c563
<             return uint(Error.MATH_ERROR);
---
>             return uint256(Error.MATH_ERROR);
464c566
<             return uint(Error.TOO_MUCH_REPAY);
---
>             return uint256(Error.TOO_MUCH_REPAY);
467c569
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
483,485c585,588
<         uint repayAmount,
<         uint seizeTokens) external {
<         cTokenBorrowed;   // currently unused
---
>         uint256 repayAmount,
>         uint256 seizeTokens
>     ) external {
>         cTokenBorrowed; // currently unused
487,490c590,593
<         liquidator;       // currently unused
<         borrower;         // currently unused
<         repayAmount;      // currently unused
<         seizeTokens;      // currently unused
---
>         liquidator; // currently unused
>         borrower; // currently unused
>         repayAmount; // currently unused
>         seizeTokens; // currently unused
510,520c613,630
<         uint seizeTokens) external returns (uint) {
<         liquidator;       // currently unused
<         borrower;         // currently unused
<         seizeTokens;      // currently unused
< 
<         if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {
<             return uint(Error.MARKET_NOT_LISTED);
<         }
< 
<         if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {
<             return uint(Error.COMPTROLLER_MISMATCH);
---
>         uint256 seizeTokens
>     ) external returns (uint256) {
>         liquidator; // currently unused
>         borrower; // currently unused
>         seizeTokens; // currently unused
> 
>         if (
>             !markets[cTokenCollateral].isListed ||
>             !markets[cTokenBorrowed].isListed
>         ) {
>             return uint256(Error.MARKET_NOT_LISTED);
>         }
> 
>         if (
>             CToken(cTokenCollateral).comptroller() !=
>             CToken(cTokenBorrowed).comptroller()
>         ) {
>             return uint256(Error.COMPTROLLER_MISMATCH);
525c635
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
541c651,652
<         uint seizeTokens) external {
---
>         uint256 seizeTokens
>     ) external {
543,546c654,657
<         cTokenBorrowed;   // currently unused
<         liquidator;       // currently unused
<         borrower;         // currently unused
<         seizeTokens;      // currently unused
---
>         cTokenBorrowed; // currently unused
>         liquidator; // currently unused
>         borrower; // currently unused
>         seizeTokens; // currently unused
561,564c672,680
<     function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint) {
<         cToken;         // currently unused
<         src;            // currently unused
<         dst;            // currently unused
---
>     function transferAllowed(
>         address cToken,
>         address src,
>         address dst,
>         uint256 transferTokens
>     ) external returns (uint256) {
>         cToken; // currently unused
>         src; // currently unused
>         dst; // currently unused
581,584c697,705
<     function transferVerify(address cToken, address src, address dst, uint transferTokens) external {
<         cToken;         // currently unused
<         src;            // currently unused
<         dst;            // currently unused
---
>     function transferVerify(
>         address cToken,
>         address src,
>         address dst,
>         uint256 transferTokens
>     ) external {
>         cToken; // currently unused
>         src; // currently unused
>         dst; // currently unused
600,605c721,726
<         uint sumCollateral;
<         uint sumBorrowPlusEffects;
<         uint cTokenBalance;
<         uint borrowBalance;
<         uint exchangeRateMantissa;
<         uint oraclePriceMantissa;
---
>         uint256 sumCollateral;
>         uint256 sumBorrowPlusEffects;
>         uint256 cTokenBalance;
>         uint256 borrowBalance;
>         uint256 exchangeRateMantissa;
>         uint256 oraclePriceMantissa;
618,619c739,752
<     function getAccountLiquidity(address account) public view returns (uint, uint, uint) {
<         (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
---
>     function getAccountLiquidity(address account)
>         public
>         view
>         returns (
>             uint256,
>             uint256,
>             uint256
>         )
>     {
>         (
>             Error err,
>             uint256 liquidity,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
621c754
<         return (uint(err), liquidity, shortfall);
---
>         return (uint256(err), liquidity, shortfall);
630,631c763,773
<     function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {
<         return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
---
>     function getAccountLiquidityInternal(address account)
>         internal
>         view
>         returns (
>             Error,
>             uint256,
>             uint256
>         )
>     {
>         return
>             getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
649,651c791,801
<         uint redeemTokens,
<         uint borrowAmount) internal view returns (Error, uint, uint) {
< 
---
>         uint256 redeemTokens,
>         uint256 borrowAmount
>     )
>         internal
>         view
>         returns (
>             Error,
>             uint256,
>             uint256
>         )
>     {
653c803
<         uint oErr;
---
>         uint256 oErr;
658c808
<         for (uint i = 0; i < assets.length; i++) {
---
>         for (uint256 i = 0; i < assets.length; i++) {
662,663c812,819
<             (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);
<             if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades
---
>             (
>                 oErr,
>                 vars.cTokenBalance,
>                 vars.borrowBalance,
>                 vars.exchangeRateMantissa
>             ) = asset.getAccountSnapshot(account);
>             if (oErr != 0) {
>                 // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades
666c822,824
<             vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});
---
>             vars.collateralFactor = Exp({
>                 mantissa: markets[address(asset)].collateralFactorMantissa
>             });
677c835,839
<             (mErr, vars.tokensToEther) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);
---
>             (mErr, vars.tokensToEther) = mulExp3(
>                 vars.collateralFactor,
>                 vars.exchangeRate,
>                 vars.oraclePrice
>             );
683c845,849
<             (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToEther, vars.cTokenBalance, vars.sumCollateral);
---
>             (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(
>                 vars.tokensToEther,
>                 vars.cTokenBalance,
>                 vars.sumCollateral
>             );
689c855,859
<             (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);
---
>             (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(
>                 vars.oraclePrice,
>                 vars.borrowBalance,
>                 vars.sumBorrowPlusEffects
>             );
698c868,872
<                 (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToEther, redeemTokens, vars.sumBorrowPlusEffects);
---
>                 (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(
>                     vars.tokensToEther,
>                     redeemTokens,
>                     vars.sumBorrowPlusEffects
>                 );
705c879,883
<                 (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);
---
>                 (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(
>                     vars.oraclePrice,
>                     borrowAmount,
>                     vars.sumBorrowPlusEffects
>                 );
714c892,896
<             return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);
---
>             return (
>                 Error.NO_ERROR,
>                 vars.sumCollateral - vars.sumBorrowPlusEffects,
>                 0
>             );
716c898,902
<             return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);
---
>             return (
>                 Error.NO_ERROR,
>                 0,
>                 vars.sumBorrowPlusEffects - vars.sumCollateral
>             );
728c914,918
<     function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint repayAmount) external view returns (uint, uint) {
---
>     function liquidateCalculateSeizeTokens(
>         address cTokenBorrowed,
>         address cTokenCollateral,
>         uint256 repayAmount
>     ) external view returns (uint256, uint256) {
730,731c920,925
<         uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));
<         uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));
---
>         uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(
>             CToken(cTokenBorrowed)
>         );
>         uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(
>             CToken(cTokenCollateral)
>         );
733c927
<             return (uint(Error.PRICE_ERROR), 0);
---
>             return (uint256(Error.PRICE_ERROR), 0);
742,743c936,938
<         uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error
<         uint seizeTokens;
---
>         uint256 exchangeRateMantissa = CToken(cTokenCollateral)
>             .exchangeRateStored(); // Note: reverts on error
>         uint256 seizeTokens;
749c944,947
<         (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);
---
>         (mathErr, numerator) = mulExp(
>             liquidationIncentiveMantissa,
>             priceBorrowedMantissa
>         );
751c949
<             return (uint(Error.MATH_ERROR), 0);
---
>             return (uint256(Error.MATH_ERROR), 0);
754c952,955
<         (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);
---
>         (mathErr, denominator) = mulExp(
>             priceCollateralMantissa,
>             exchangeRateMantissa
>         );
756c957
<             return (uint(Error.MATH_ERROR), 0);
---
>             return (uint256(Error.MATH_ERROR), 0);
761c962
<             return (uint(Error.MATH_ERROR), 0);
---
>             return (uint256(Error.MATH_ERROR), 0);
766c967
<             return (uint(Error.MATH_ERROR), 0);
---
>             return (uint256(Error.MATH_ERROR), 0);
769c970
<         return (uint(Error.NO_ERROR), seizeTokens);
---
>         return (uint256(Error.NO_ERROR), seizeTokens);
775,779c976,980
<       * @notice Sets a new price oracle for the comptroller
<       * @dev Admin function to set a new price oracle
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setPriceOracle(PriceOracle newOracle) public returns (uint) {
---
>      * @notice Sets a new price oracle for the comptroller
>      * @dev Admin function to set a new price oracle
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {
782c983,987
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);
---
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK
>                 );
797c1002
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
801,806c1006,1014
<       * @notice Sets the closeFactor used when liquidating borrows
<       * @dev Admin function to set closeFactor
<       * @param newCloseFactorMantissa New close factor, scaled by 1e18
<       * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
<       */
<     function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {
---
>      * @notice Sets the closeFactor used when liquidating borrows
>      * @dev Admin function to set closeFactor
>      * @param newCloseFactorMantissa New close factor, scaled by 1e18
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setCloseFactor(uint256 newCloseFactorMantissa)
>         external
>         returns (uint256)
>     {
809c1017,1021
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);
---
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK
>                 );
815c1027,1031
<             return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);
---
>             return
>                 fail(
>                     Error.INVALID_CLOSE_FACTOR,
>                     FailureInfo.SET_CLOSE_FACTOR_VALIDATION
>                 );
820c1036,1040
<             return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);
---
>             return
>                 fail(
>                     Error.INVALID_CLOSE_FACTOR,
>                     FailureInfo.SET_CLOSE_FACTOR_VALIDATION
>                 );
823c1043
<         uint oldCloseFactorMantissa = closeFactorMantissa;
---
>         uint256 oldCloseFactorMantissa = closeFactorMantissa;
827c1047
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
831,837c1051,1060
<       * @notice Sets the collateralFactor for a market
<       * @dev Admin function to set per-market collateralFactor
<       * @param cToken The market to set the factor on
<       * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18
<       * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
<       */
<     function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint256) {
---
>      * @notice Sets the collateralFactor for a market
>      * @dev Admin function to set per-market collateralFactor
>      * @param cToken The market to set the factor on
>      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setCollateralFactor(
>         CToken cToken,
>         uint256 newCollateralFactorMantissa
>     ) external returns (uint256) {
839,840c1062,1067
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK
>                 );
846c1073,1077
<             return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_LISTED,
>                     FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS
>                 );
849c1080,1082
<         Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});
---
>         Exp memory newCollateralFactorExp = Exp({
>             mantissa: newCollateralFactorMantissa
>         });
854c1087,1091
<             return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);
---
>             return
>                 fail(
>                     Error.INVALID_COLLATERAL_FACTOR,
>                     FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION
>                 );
858,859c1095,1103
<         if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {
<             return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);
---
>         if (
>             newCollateralFactorMantissa != 0 &&
>             oracle.getUnderlyingPrice(cToken) == 0
>         ) {
>             return
>                 fail(
>                     Error.PRICE_ERROR,
>                     FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE
>                 );
863c1107
<         uint oldCollateralFactorMantissa = market.collateralFactorMantissa;
---
>         uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;
867c1111,1115
<         emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);
---
>         emit NewCollateralFactor(
>             cToken,
>             oldCollateralFactorMantissa,
>             newCollateralFactorMantissa
>         );
869c1117
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
873,878c1121,1126
<       * @notice Sets maxAssets which controls how many markets can be entered
<       * @dev Admin function to set maxAssets
<       * @param newMaxAssets New max assets
<       * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
<       */
<     function _setMaxAssets(uint newMaxAssets) external returns (uint) {
---
>      * @notice Sets maxAssets which controls how many markets can be entered
>      * @dev Admin function to set maxAssets
>      * @param newMaxAssets New max assets
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setMaxAssets(uint256 newMaxAssets) external returns (uint256) {
881c1129,1133
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);
---
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_MAX_ASSETS_OWNER_CHECK
>                 );
884c1136
<         uint oldMaxAssets = maxAssets;
---
>         uint256 oldMaxAssets = maxAssets;
888c1140
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
892,897c1144,1152
<       * @notice Sets liquidationIncentive
<       * @dev Admin function to set liquidationIncentive
<       * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18
<       * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
<       */
<     function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {
---
>      * @notice Sets liquidationIncentive
>      * @dev Admin function to set liquidationIncentive
>      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)
>         external
>         returns (uint256)
>     {
900c1155,1159
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);
---
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK
>                 );
904,905c1163,1168
<         Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});
<         Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});
---
>         Exp memory newLiquidationIncentive = Exp({
>             mantissa: newLiquidationIncentiveMantissa
>         });
>         Exp memory minLiquidationIncentive = Exp({
>             mantissa: liquidationIncentiveMinMantissa
>         });
907c1170,1174
<             return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);
---
>             return
>                 fail(
>                     Error.INVALID_LIQUIDATION_INCENTIVE,
>                     FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION
>                 );
910c1177,1179
<         Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});
---
>         Exp memory maxLiquidationIncentive = Exp({
>             mantissa: liquidationIncentiveMaxMantissa
>         });
912c1181,1185
<             return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);
---
>             return
>                 fail(
>                     Error.INVALID_LIQUIDATION_INCENTIVE,
>                     FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION
>                 );
916c1189
<         uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;
---
>         uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;
922c1195,1198
<         emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);
---
>         emit NewLiquidationIncentive(
>             oldLiquidationIncentiveMantissa,
>             newLiquidationIncentiveMantissa
>         );
924c1200
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
928,935c1204,1215
<       * @notice Add the market to the markets mapping and set it as listed
<       * @dev Admin function to set isListed and add support for the market
<       * @param cToken The address of the market (token) to list
<       * @return uint 0=success, otherwise a failure. (See enum Error for details)
<       */
<     function _supportMarket(CToken cToken) external returns (uint) {
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);
---
>      * @notice Add the market to the markets mapping and set it as listed
>      * @dev Admin function to set isListed and add support for the market
>      * @param cToken The address of the market (token) to list
>      * @return uint 0=success, otherwise a failure. (See enum Error for details)
>      */
>     function _supportMarket(CToken cToken) external returns (uint256) {
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SUPPORT_MARKET_OWNER_CHECK
>                 );
939c1219,1223
<             return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);
---
>             return
>                 fail(
>                     Error.MARKET_ALREADY_LISTED,
>                     FailureInfo.SUPPORT_MARKET_EXISTS
>                 );
944c1228,1231
<         markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});
---
>         markets[address(cToken)] = Market({
>             isListed: true,
>             collateralFactorMantissa: 0
>         });
947c1234
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
950,952c1237,1248
<     function _become(Unitroller unitroller, PriceOracle _oracle, uint _closeFactorMantissa, uint _maxAssets, bool reinitializing) public {
<         require(msg.sender == unitroller.admin(), "only unitroller admin can change brains");
<         uint changeStatus = unitroller._acceptImplementation();
---
>     function _become(
>         Unitroller unitroller,
>         PriceOracle _oracle,
>         uint256 _closeFactorMantissa,
>         uint256 _maxAssets,
>         bool reinitializing
>     ) public {
>         require(
>             msg.sender == unitroller.admin(),
>             "only unitroller admin can change brains"
>         );
>         uint256 changeStatus = unitroller._acceptImplementation();
957c1253,1255
<             ComptrollerG1 freshBrainedComptroller = ComptrollerG1(address(unitroller));
---
>             ComptrollerG1 freshBrainedComptroller = ComptrollerG1(
>                 address(unitroller)
>             );
960,961c1258,1259
<             uint err = freshBrainedComptroller._setPriceOracle(_oracle);
<             require (err == uint(Error.NO_ERROR), "set price oracle error");
---
>             uint256 err = freshBrainedComptroller._setPriceOracle(_oracle);
>             require(err == uint256(Error.NO_ERROR), "set price oracle error");
965c1263
<             require (err == uint(Error.NO_ERROR), "set close factor error");
---
>             require(err == uint256(Error.NO_ERROR), "set close factor error");
969c1267
<             require (err == uint(Error.NO_ERROR), "set max asssets error");
---
>             require(err == uint256(Error.NO_ERROR), "set max asssets error");
972,973c1270,1276
<             err = freshBrainedComptroller._setLiquidationIncentive(liquidationIncentiveMinMantissa);
<             require (err == uint(Error.NO_ERROR), "set liquidation incentive error");
---
>             err = freshBrainedComptroller._setLiquidationIncentive(
>                 liquidationIncentiveMinMantissa
>             );
>             require(
>                 err == uint256(Error.NO_ERROR),
>                 "set liquidation incentive error"
>             );
984,990c1287,1290
<         bool initializing = (
<                 msg.sender == comptrollerImplementation
<                 &&
<                 //solium-disable-next-line security/no-tx-origin
<                 tx.origin == admin
<         );
<         bool isAdmin = msg.sender == admin;
---
>         bool initializing = (msg.sender == comptrollerImplementation &&
>             //solium-disable-next-line security/no-tx-origin
>             tx.origin == admin);
>         bool isAdmin = hasAdminRights();
993c1293
< }
\ No newline at end of file
---
> }
Only in ../compound-protocol/contracts/: ComptrollerG2.sol
Only in ../compound-protocol/contracts/: ComptrollerG3.sol
Only in ../compound-protocol/contracts/: ComptrollerG4.sol
Only in ../compound-protocol/contracts/: ComptrollerG5.sol
Only in ../compound-protocol/contracts/: ComptrollerG6.sol
Only in ../compound-protocol/contracts/: ComptrollerG7.sol
diff -x .git -r ../compound-protocol/contracts/ComptrollerInterface.sol src/core/ComptrollerInterface.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
9,10c9,13
<     function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
<     function exitMarket(address cToken) external returns (uint);
---
>     function enterMarkets(address[] calldata cTokens)
>         external
>         returns (uint256[] memory);
> 
>     function exitMarket(address cToken) external returns (uint256);
14,15c17,54
<     function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);
<     function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;
---
>     function mintAllowed(
>         address cToken,
>         address minter,
>         uint256 mintAmount
>     ) external returns (uint256);
> 
>     function mintWithinLimits(
>         address cToken,
>         uint256 exchangeRateMantissa,
>         uint256 accountTokens,
>         uint256 mintAmount
>     ) external returns (uint256);
> 
>     function mintVerify(
>         address cToken,
>         address minter,
>         uint256 mintAmount,
>         uint256 mintTokens
>     ) external;
> 
>     function redeemAllowed(
>         address cToken,
>         address redeemer,
>         uint256 redeemTokens
>     ) external returns (uint256);
> 
>     function redeemVerify(
>         address cToken,
>         address redeemer,
>         uint256 redeemAmount,
>         uint256 redeemTokens
>     ) external;
> 
>     function borrowAllowed(
>         address cToken,
>         address borrower,
>         uint256 borrowAmount
>     ) external returns (uint256);
17,18c56,58
<     function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);
<     function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;
---
>     function borrowWithinLimits(address cToken, uint256 accountBorrowsNew)
>         external
>         returns (uint256);
20,21c60,64
<     function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);
<     function borrowVerify(address cToken, address borrower, uint borrowAmount) external;
---
>     function borrowVerify(
>         address cToken,
>         address borrower,
>         uint256 borrowAmount
>     ) external;
27c70,72
<         uint repayAmount) external returns (uint);
---
>         uint256 repayAmount
>     ) external returns (uint256);
> 
32,33c77,79
<         uint repayAmount,
<         uint borrowerIndex) external;
---
>         uint256 repayAmount,
>         uint256 borrowerIndex
>     ) external;
40c86,88
<         uint repayAmount) external returns (uint);
---
>         uint256 repayAmount
>     ) external returns (uint256);
> 
46,47c94,96
<         uint repayAmount,
<         uint seizeTokens) external;
---
>         uint256 repayAmount,
>         uint256 seizeTokens
>     ) external;
54c103,105
<         uint seizeTokens) external returns (uint);
---
>         uint256 seizeTokens
>     ) external returns (uint256);
> 
60c111,112
<         uint seizeTokens) external;
---
>         uint256 seizeTokens
>     ) external;
62,63c114,126
<     function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);
<     function transferVerify(address cToken, address src, address dst, uint transferTokens) external;
---
>     function transferAllowed(
>         address cToken,
>         address src,
>         address dst,
>         uint256 transferTokens
>     ) external returns (uint256);
> 
>     function transferVerify(
>         address cToken,
>         address src,
>         address dst,
>         uint256 transferTokens
>     ) external;
70c133,140
<         uint repayAmount) external view returns (uint, uint);
---
>         uint256 repayAmount
>     ) external view returns (uint256, uint256);
> 
>     /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/
> 
>     function _beforeNonReentrant() external;
> 
>     function _afterNonReentrant() external;
diff -x .git -r ../compound-protocol/contracts/Comptroller.sol src/core/Comptroller.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
3a4
> import "./CErc20.sol";
4a6
> import "./Exponential.sol";
9c11
< import "./Governance/Comp.sol";
---
> import "./RewardsDistributorDelegate.sol";
13a16
>  * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).
15c18,23
< contract Comptroller is ComptrollerV7Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {
---
> contract Comptroller is
>     ComptrollerV3Storage,
>     ComptrollerInterface,
>     ComptrollerErrorReporter,
>     Exponential
> {
18a27,29
>     /// @notice Emitted when an admin unsupports a market
>     event MarketUnlisted(CToken cToken);
> 
26c37,40
<     event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);
---
>     event NewCloseFactor(
>         uint256 oldCloseFactorMantissa,
>         uint256 newCloseFactorMantissa
>     );
29c43,47
<     event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);
---
>     event NewCollateralFactor(
>         CToken cToken,
>         uint256 oldCollateralFactorMantissa,
>         uint256 newCollateralFactorMantissa
>     );
32c50,53
<     event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);
---
>     event NewLiquidationIncentive(
>         uint256 oldLiquidationIncentiveMantissa,
>         uint256 newLiquidationIncentiveMantissa
>     );
35c56,59
<     event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);
---
>     event NewPriceOracle(
>         PriceOracle oldPriceOracle,
>         PriceOracle newPriceOracle
>     );
46,53c70,71
<     /// @notice Emitted when a new borrow-side COMP speed is calculated for a market
<     event CompBorrowSpeedUpdated(CToken indexed cToken, uint newSpeed);
< 
<     /// @notice Emitted when a new supply-side COMP speed is calculated for a market
<     event CompSupplySpeedUpdated(CToken indexed cToken, uint newSpeed);
< 
<     /// @notice Emitted when a new COMP speed is set for a contributor
<     event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);
---
>     /// @notice Emitted when the whitelist enforcement is changed
>     event WhitelistEnforcementChanged(bool enforce);
55,56c73,74
<     /// @notice Emitted when COMP is distributed to a supplier
<     event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);
---
>     /// @notice Emitted when auto implementations are toggled
>     event AutoImplementationsToggled(bool enabled);
58,59c76,77
<     /// @notice Emitted when COMP is distributed to a borrower
<     event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);
---
>     /// @notice Emitted when supply cap for a cToken is changed
>     event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);
62c80
<     event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);
---
>     event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);
65,71c83,86
<     event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);
< 
<     /// @notice Emitted when COMP is granted by admin
<     event CompGranted(address recipient, uint amount);
< 
<     /// @notice Emitted when COMP accrued for a user has been manually adjusted.
<     event CompAccruedAdjusted(address indexed user, uint oldCompAccrued, uint newCompAccrued);
---
>     event NewBorrowCapGuardian(
>         address oldBorrowCapGuardian,
>         address newBorrowCapGuardian
>     );
73,77c88,89
<     /// @notice Emitted when COMP receivable for a user has been updated.
<     event CompReceivableUpdated(address indexed user, uint oldCompReceivable, uint newCompReceivable);
< 
<     /// @notice The initial COMP index for a market
<     uint224 public constant compInitialIndex = 1e36;
---
>     /// @notice Emitted when a new RewardsDistributor contract is added to hooks
>     event AddedRewardsDistributor(address rewardsDistributor);
80c92
<     uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05
---
>     uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05
83c95
<     uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9
---
>     uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9
86c98
<     uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9
---
>     uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9
88,90c100,104
<     constructor() public {
<         admin = msg.sender;
<     }
---
>     // liquidationIncentiveMantissa must be no less than this value
>     uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0
> 
>     // liquidationIncentiveMantissa must be no greater than this value
>     uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5
99c113,117
<     function getAssetsIn(address account) external view returns (CToken[] memory) {
---
>     function getAssetsIn(address account)
>         external
>         view
>         returns (CToken[] memory)
>     {
111c129,133
<     function checkMembership(address account, CToken cToken) external view returns (bool) {
---
>     function checkMembership(address account, CToken cToken)
>         external
>         view
>         returns (bool)
>     {
120,121c142,146
<     function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {
<         uint len = cTokens.length;
---
>     function enterMarkets(address[] memory cTokens)
>         public
>         returns (uint256[] memory)
>     {
>         uint256 len = cTokens.length;
123,124c148,149
<         uint[] memory results = new uint[](len);
<         for (uint i = 0; i < len; i++) {
---
>         uint256[] memory results = new uint256[](len);
>         for (uint256 i = 0; i < len; i++) {
127c152
<             results[i] = uint(addToMarketInternal(cToken, msg.sender));
---
>             results[i] = uint256(addToMarketInternal(cToken, msg.sender));
139c164,167
<     function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {
---
>     function addToMarketInternal(CToken cToken, address borrower)
>         internal
>         returns (Error)
>     {
159a188,194
>         // Add to allBorrowers
>         if (!borrowers[borrower]) {
>             allBorrowers.push(borrower);
>             borrowers[borrower] = true;
>             borrowerIndexes[borrower] = allBorrowers.length - 1;
>         }
> 
168c203
<      *  or be providing necessary collateral for an outstanding borrow.
---
>      *  or be providing neccessary collateral for an outstanding borrow.
172c207
<     function exitMarket(address cTokenAddress) external returns (uint) {
---
>     function exitMarket(address cTokenAddress) external returns (uint256) {
175c210,211
<         (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);
---
>         (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken
>             .getAccountSnapshot(msg.sender);
180c216,220
<             return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);
---
>             return
>                 fail(
>                     Error.NONZERO_BORROW_BALANCE,
>                     FailureInfo.EXIT_MARKET_BALANCE_OWED
>                 );
184c224,228
<         uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);
---
>         uint256 allowed = redeemAllowedInternal(
>             cTokenAddress,
>             msg.sender,
>             tokensHeld
>         );
186c230,235
<             return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);
---
>             return
>                 failOpaque(
>                     Error.REJECTION,
>                     FailureInfo.EXIT_MARKET_REJECTION,
>                     allowed
>                 );
193c242
<             return uint(Error.NO_ERROR);
---
>             return uint256(Error.NO_ERROR);
202,204c251,253
<         uint len = userAssetList.length;
<         uint assetIndex = len;
<         for (uint i = 0; i < len; i++) {
---
>         uint256 len = userAssetList.length;
>         uint256 assetIndex = len;
>         for (uint256 i = 0; i < len; i++) {
218a268,284
>         // If the user has exited all markets, remove them from the `allBorrowers` array
>         if (storedList.length == 0) {
>             uint256 borrowerIndex = borrowerIndexes[msg.sender];
> 
>             // If borrower not at the end of the borrower array, replace it with the item at the end of the borrower array
>             if (borrowerIndex < allBorrowers.length - 1) {
>                 address lastElement = allBorrowers[allBorrowers.length - 1];
>                 allBorrowers[borrowerIndex] = lastElement; // Copy last item in list to location of item to be removed
>                 borrowerIndexes[lastElement] = borrowerIndex; // Set borrower index of moved item to correct index
>             }
> 
>             // Remove the last element of the borrower array
>             allBorrowers.length--; // Reduce length by 1
>             borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund
>             borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)
>         }
> 
221c287
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
233c299,303
<     function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint) {
---
>     function mintAllowed(
>         address cToken,
>         address minter,
>         uint256 mintAmount
>     ) external returns (uint256) {
240a311
>         // Make sure market is listed
242c313,349
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
>         }
> 
>         // Make sure minter is whitelisted
>         if (enforceWhitelist && !whitelist[minter]) {
>             return uint256(Error.SUPPLIER_NOT_WHITELISTED);
>         }
> 
>         // Check supply cap
>         uint256 supplyCap = supplyCaps[cToken];
>         // Supply cap of 0 corresponds to unlimited supplying
>         if (supplyCap != 0) {
>             uint256 totalCash = CToken(cToken).getCash();
>             uint256 totalBorrows = CToken(cToken).totalBorrows();
>             uint256 totalReserves = CToken(cToken).totalReserves();
>             uint256 totalFuseFees = CToken(cToken).totalFuseFees();
>             uint256 totalAdminFees = CToken(cToken).totalAdminFees();
> 
>             // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)
>             (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(
>                 totalCash,
>                 totalBorrows,
>                 add_(add_(totalReserves, totalFuseFees), totalAdminFees)
>             );
>             if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);
> 
>             uint256 nextTotalUnderlyingSupply;
>             (mathErr, nextTotalUnderlyingSupply) = addUInt(
>                 totalUnderlyingSupply,
>                 mintAmount
>             );
>             if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);
> 
>             require(
>                 nextTotalUnderlyingSupply < supplyCap,
>                 "market supply cap reached"
>             );
246,247c353
<         updateCompSupplyIndex(cToken);
<         distributeSupplierComp(cToken, minter);
---
>         flywheelPreSupplierAction(cToken, minter);
249c355
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
259c365,370
<     function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) external {
---
>     function mintVerify(
>         address cToken,
>         address minter,
>         uint256 actualMintAmount,
>         uint256 mintTokens
>     ) external {
269a381,383
> 
>         // Add minter to suppliers mapping
>         suppliers[minter] = true;
279,281c393,399
<     function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint) {
<         uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);
<         if (allowed != uint(Error.NO_ERROR)) {
---
>     function redeemAllowed(
>         address cToken,
>         address redeemer,
>         uint256 redeemTokens
>     ) external returns (uint256) {
>         uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);
>         if (allowed != uint256(Error.NO_ERROR)) {
286,287c404
<         updateCompSupplyIndex(cToken);
<         distributeSupplierComp(cToken, redeemer);
---
>         flywheelPreSupplierAction(cToken, redeemer);
289c406
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
292c409,413
<     function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {
---
>     function redeemAllowedInternal(
>         address cToken,
>         address redeemer,
>         uint256 redeemTokens
>     ) internal view returns (uint256) {
294c415
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
299c420
<             return uint(Error.NO_ERROR);
---
>             return uint256(Error.NO_ERROR);
303c424,433
<         (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);
---
>         (
>             Error err,
>             ,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(
>                 redeemer,
>                 CToken(cToken),
>                 redeemTokens,
>                 0
>             );
305c435
<             return uint(err);
---
>             return uint256(err);
308c438
<             return uint(Error.INSUFFICIENT_LIQUIDITY);
---
>             return uint256(Error.INSUFFICIENT_LIQUIDITY);
311c441
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
321c451,456
<     function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external {
---
>     function redeemVerify(
>         address cToken,
>         address redeemer,
>         uint256 redeemAmount,
>         uint256 redeemTokens
>     ) external {
339c474,478
<     function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {
---
>     function borrowAllowed(
>         address cToken,
>         address borrower,
>         uint256 borrowAmount
>     ) external returns (uint256) {
342a482
>         // Make sure market is listed
344c484
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
354c494
<                 return uint(err);
---
>                 return uint256(err);
360a501
>         // Make sure oracle price is available
362c503
<             return uint(Error.PRICE_ERROR);
---
>             return uint256(Error.PRICE_ERROR);
364a506,509
>         // Make sure borrower is whitelisted
>         if (enforceWhitelist && !whitelist[borrower]) {
>             return uint256(Error.SUPPLIER_NOT_WHITELISTED);
>         }
366c511,512
<         uint borrowCap = borrowCaps[cToken];
---
>         // Check borrow cap
>         uint256 borrowCap = borrowCaps[cToken];
369,370c515,520
<             uint totalBorrows = CToken(cToken).totalBorrows();
<             uint nextTotalBorrows = add_(totalBorrows, borrowAmount);
---
>             uint256 totalBorrows = CToken(cToken).totalBorrows();
>             (MathError mathErr, uint256 nextTotalBorrows) = addUInt(
>                 totalBorrows,
>                 borrowAmount
>             );
>             if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);
374c524,537
<         (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);
---
>         // Keep the flywheel moving
>         flywheelPreBorrowerAction(cToken, borrower);
> 
>         // Perform a hypothetical liquidity check to guard against shortfall
>         (
>             Error err,
>             ,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(
>                 borrower,
>                 CToken(cToken),
>                 0,
>                 borrowAmount
>             );
376c539
<             return uint(err);
---
>             return uint256(err);
379c542
<             return uint(Error.INSUFFICIENT_LIQUIDITY);
---
>             return uint256(Error.INSUFFICIENT_LIQUIDITY);
382,385c545,546
<         // Keep the flywheel moving
<         Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});
<         updateCompBorrowIndex(cToken, borrowIndex);
<         distributeBorrowerComp(cToken, borrower, borrowIndex);
---
>         return uint256(Error.NO_ERROR);
>     }
387c548,595
<         return uint(Error.NO_ERROR);
---
>     /**
>      * @notice Checks if the account should be allowed to borrow the underlying asset of the given market
>      * @param cToken Asset whose underlying is being borrowed
>      * @param accountBorrowsNew The user's new borrow balance of the underlying asset
>      */
>     function borrowWithinLimits(address cToken, uint256 accountBorrowsNew)
>         external
>         returns (uint256)
>     {
>         // Check if min borrow exists
>         uint256 minBorrowEth = fuseAdmin.minBorrowEth();
> 
>         if (minBorrowEth > 0) {
>             // Get new underlying borrow balance of account for this cToken
>             uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(
>                 CToken(cToken)
>             );
>             if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);
>             (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(
>                 Exp({mantissa: oraclePriceMantissa}),
>                 accountBorrowsNew
>             );
>             if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);
> 
>             // Check against min borrow
>             if (borrowBalanceEth < minBorrowEth)
>                 return uint256(Error.BORROW_BELOW_MIN);
>         }
> 
>         // Return no error
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice Checks if the account should be allowed to borrow the underlying asset of the given market
>      * @param cToken Asset whose underlying is being borrowed
>      * @param exchangeRateMantissa Underlying/cToken exchange rate
>      * @param accountTokens Initial account cToken balance
>      * @param accountTokens Underlying amount to mint
>      */
>     function mintWithinLimits(
>         address cToken,
>         uint256 exchangeRateMantissa,
>         uint256 accountTokens,
>         uint256 mintAmount
>     ) external returns (uint256) {
>         // Return no error
>         return uint256(Error.NO_ERROR);
396c604,608
<     function borrowVerify(address cToken, address borrower, uint borrowAmount) external {
---
>     function borrowVerify(
>         address cToken,
>         address borrower,
>         uint256 borrowAmount
>     ) external {
420c632,633
<         uint repayAmount) external returns (uint) {
---
>         uint256 repayAmount
>     ) external returns (uint256) {
425a639
>         // Make sure market is listed
427c641
<             return uint(Error.MARKET_NOT_LISTED);
---
>             return uint256(Error.MARKET_NOT_LISTED);
431,433c645
<         Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});
<         updateCompBorrowIndex(cToken, borrowIndex);
<         distributeBorrowerComp(cToken, borrower, borrowIndex);
---
>         flywheelPreBorrowerAction(cToken, borrower);
435c647
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
449,450c661,663
<         uint actualRepayAmount,
<         uint borrowerIndex) external {
---
>         uint256 actualRepayAmount,
>         uint256 borrowerIndex
>     ) external {
477c690,691
<         uint repayAmount) external returns (uint) {
---
>         uint256 repayAmount
>     ) external returns (uint256) {
481,482c695,700
<         if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {
<             return uint(Error.MARKET_NOT_LISTED);
---
>         // Make sure markets are listed
>         if (
>             !markets[cTokenBorrowed].isListed ||
>             !markets[cTokenCollateral].isListed
>         ) {
>             return uint256(Error.MARKET_NOT_LISTED);
485c703,706
<         uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);
---
>         // Get borrowers's underlying borrow balance
>         uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(
>             borrower
>         );
489c710,713
<             require(borrowBalance >= repayAmount, "Can not repay more than the total borrow");
---
>             require(
>                 borrowBalance >= repayAmount,
>                 "Can not repay more than the total borrow"
>             );
492c716,718
<             (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);
---
>             (Error err, , uint256 shortfall) = getAccountLiquidityInternal(
>                 borrower
>             );
494c720
<                 return uint(err);
---
>                 return uint256(err);
498c724
<                 return uint(Error.INSUFFICIENT_SHORTFALL);
---
>                 return uint256(Error.INSUFFICIENT_SHORTFALL);
502c728,731
<             uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);
---
>             uint256 maxClose = mul_ScalarTruncate(
>                 Exp({mantissa: closeFactorMantissa}),
>                 borrowBalance
>             );
504c733
<                 return uint(Error.TOO_MUCH_REPAY);
---
>                 return uint256(Error.TOO_MUCH_REPAY);
507c736,737
<         return uint(Error.NO_ERROR);
---
> 
>         return uint256(Error.NO_ERROR);
523,524c753,755
<         uint actualRepayAmount,
<         uint seizeTokens) external {
---
>         uint256 actualRepayAmount,
>         uint256 seizeTokens
>     ) external {
552c783,784
<         uint seizeTokens) external returns (uint) {
---
>         uint256 seizeTokens
>     ) external returns (uint256) {
556a789,790
>         liquidator;
>         borrower;
559,560c793,798
<         if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {
<             return uint(Error.MARKET_NOT_LISTED);
---
>         // Make sure markets are listed
>         if (
>             !markets[cTokenCollateral].isListed ||
>             !markets[cTokenBorrowed].isListed
>         ) {
>             return uint256(Error.MARKET_NOT_LISTED);
563,564c801,806
<         if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {
<             return uint(Error.COMPTROLLER_MISMATCH);
---
>         // Make sure cToken Comptrollers are identical
>         if (
>             CToken(cTokenCollateral).comptroller() !=
>             CToken(cTokenBorrowed).comptroller()
>         ) {
>             return uint256(Error.COMPTROLLER_MISMATCH);
568,570c810
<         updateCompSupplyIndex(cTokenCollateral);
<         distributeSupplierComp(cTokenCollateral, borrower);
<         distributeSupplierComp(cTokenCollateral, liquidator);
---
>         flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);
572c812
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
588c828,829
<         uint seizeTokens) external {
---
>         uint256 seizeTokens
>     ) external {
610c851,856
<     function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint) {
---
>     function transferAllowed(
>         address cToken,
>         address src,
>         address dst,
>         uint256 transferTokens
>     ) external returns (uint256) {
616,617c862,863
<         uint allowed = redeemAllowedInternal(cToken, src, transferTokens);
<         if (allowed != uint(Error.NO_ERROR)) {
---
>         uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);
>         if (allowed != uint256(Error.NO_ERROR)) {
622,624c868
<         updateCompSupplyIndex(cToken);
<         distributeSupplierComp(cToken, src);
<         distributeSupplierComp(cToken, dst);
---
>         flywheelPreTransferAction(cToken, src, dst);
626c870
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
636c880,885
<     function transferVerify(address cToken, address src, address dst, uint transferTokens) external {
---
>     function transferVerify(
>         address cToken,
>         address src,
>         address dst,
>         uint256 transferTokens
>     ) external {
648a898,941
>     /*** Flywheel Hooks ***/
> 
>     /**
>      * @notice Keeps the flywheel moving pre-mint and pre-redeem
>      * @param cToken The relevant market
>      * @param supplier The minter/redeemer
>      */
>     function flywheelPreSupplierAction(address cToken, address supplier)
>         internal
>     {
>         for (uint256 i = 0; i < rewardsDistributors.length; i++)
>             RewardsDistributorDelegate(rewardsDistributors[i])
>                 .flywheelPreSupplierAction(cToken, supplier);
>     }
> 
>     /**
>      * @notice Keeps the flywheel moving pre-borrow and pre-repay
>      * @param cToken The relevant market
>      * @param borrower The borrower
>      */
>     function flywheelPreBorrowerAction(address cToken, address borrower)
>         internal
>     {
>         for (uint256 i = 0; i < rewardsDistributors.length; i++)
>             RewardsDistributorDelegate(rewardsDistributors[i])
>                 .flywheelPreBorrowerAction(cToken, borrower);
>     }
> 
>     /**
>      * @notice Keeps the flywheel moving pre-transfer and pre-seize
>      * @param cToken The relevant market
>      * @param src The account which sources the tokens
>      * @param dst The account which receives the tokens
>      */
>     function flywheelPreTransferAction(
>         address cToken,
>         address src,
>         address dst
>     ) internal {
>         for (uint256 i = 0; i < rewardsDistributors.length; i++)
>             RewardsDistributorDelegate(rewardsDistributors[i])
>                 .flywheelPreTransferAction(cToken, src, dst);
>     }
> 
657,662c950,955
<         uint sumCollateral;
<         uint sumBorrowPlusEffects;
<         uint cTokenBalance;
<         uint borrowBalance;
<         uint exchangeRateMantissa;
<         uint oraclePriceMantissa;
---
>         uint256 sumCollateral;
>         uint256 sumBorrowPlusEffects;
>         uint256 cTokenBalance;
>         uint256 borrowBalance;
>         uint256 exchangeRateMantissa;
>         uint256 oraclePriceMantissa;
675,676c968,981
<     function getAccountLiquidity(address account) public view returns (uint, uint, uint) {
<         (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
---
>     function getAccountLiquidity(address account)
>         public
>         view
>         returns (
>             uint256,
>             uint256,
>             uint256
>         )
>     {
>         (
>             Error err,
>             uint256 liquidity,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
678c983
<         return (uint(err), liquidity, shortfall);
---
>         return (uint256(err), liquidity, shortfall);
687,688c992,1002
<     function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {
<         return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
---
>     function getAccountLiquidityInternal(address account)
>         internal
>         view
>         returns (
>             Error,
>             uint256,
>             uint256
>         )
>     {
>         return
>             getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
704,707c1018,1039
<         uint redeemTokens,
<         uint borrowAmount) public view returns (uint, uint, uint) {
<         (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);
<         return (uint(err), liquidity, shortfall);
---
>         uint256 redeemTokens,
>         uint256 borrowAmount
>     )
>         public
>         view
>         returns (
>             uint256,
>             uint256,
>             uint256
>         )
>     {
>         (
>             Error err,
>             uint256 liquidity,
>             uint256 shortfall
>         ) = getHypotheticalAccountLiquidityInternal(
>                 account,
>                 CToken(cTokenModify),
>                 redeemTokens,
>                 borrowAmount
>             );
>         return (uint256(err), liquidity, shortfall);
725,727c1057,1067
<         uint redeemTokens,
<         uint borrowAmount) internal view returns (Error, uint, uint) {
< 
---
>         uint256 redeemTokens,
>         uint256 borrowAmount
>     )
>         internal
>         view
>         returns (
>             Error,
>             uint256,
>             uint256
>         )
>     {
729c1069
<         uint oErr;
---
>         uint256 oErr;
733c1073
<         for (uint i = 0; i < assets.length; i++) {
---
>         for (uint256 i = 0; i < assets.length; i++) {
737,738c1077,1084
<             (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);
<             if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades
---
>             (
>                 oErr,
>                 vars.cTokenBalance,
>                 vars.borrowBalance,
>                 vars.exchangeRateMantissa
>             ) = asset.getAccountSnapshot(account);
>             if (oErr != 0) {
>                 // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades
741c1087,1089
<             vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});
---
>             vars.collateralFactor = Exp({
>                 mantissa: markets[address(asset)].collateralFactorMantissa
>             });
752c1100,1103
<             vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);
---
>             vars.tokensToDenom = mul_(
>                 mul_(vars.collateralFactor, vars.exchangeRate),
>                 vars.oraclePrice
>             );
755c1106,1110
<             vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);
---
>             vars.sumCollateral = mul_ScalarTruncateAddUInt(
>                 vars.tokensToDenom,
>                 vars.cTokenBalance,
>                 vars.sumCollateral
>             );
758c1113,1117
<             vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);
---
>             vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(
>                 vars.oraclePrice,
>                 vars.borrowBalance,
>                 vars.sumBorrowPlusEffects
>             );
764c1123,1127
<                 vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);
---
>                 vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(
>                     vars.tokensToDenom,
>                     redeemTokens,
>                     vars.sumBorrowPlusEffects
>                 );
768c1131,1135
<                 vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);
---
>                 vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(
>                     vars.oraclePrice,
>                     borrowAmount,
>                     vars.sumBorrowPlusEffects
>                 );
774c1141,1145
<             return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);
---
>             return (
>                 Error.NO_ERROR,
>                 vars.sumCollateral - vars.sumBorrowPlusEffects,
>                 0
>             );
776c1147,1151
<             return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);
---
>             return (
>                 Error.NO_ERROR,
>                 0,
>                 vars.sumBorrowPlusEffects - vars.sumCollateral
>             );
788c1163,1167
<     function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {
---
>     function liquidateCalculateSeizeTokens(
>         address cTokenBorrowed,
>         address cTokenCollateral,
>         uint256 actualRepayAmount
>     ) external view returns (uint256, uint256) {
790,791c1169,1174
<         uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));
<         uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));
---
>         uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(
>             CToken(cTokenBorrowed)
>         );
>         uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(
>             CToken(cTokenCollateral)
>         );
793c1176
<             return (uint(Error.PRICE_ERROR), 0);
---
>             return (uint256(Error.PRICE_ERROR), 0);
802,803c1185,1187
<         uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error
<         uint seizeTokens;
---
>         uint256 exchangeRateMantissa = CToken(cTokenCollateral)
>             .exchangeRateStored(); // Note: reverts on error
>         uint256 seizeTokens;
808,809c1192,1199
<         numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));
<         denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));
---
>         numerator = mul_(
>             Exp({mantissa: liquidationIncentiveMantissa}),
>             Exp({mantissa: priceBorrowedMantissa})
>         );
>         denominator = mul_(
>             Exp({mantissa: priceCollateralMantissa}),
>             Exp({mantissa: exchangeRateMantissa})
>         );
814c1204
<         return (uint(Error.NO_ERROR), seizeTokens);
---
>         return (uint256(Error.NO_ERROR), seizeTokens);
820,824c1210,1217
<       * @notice Sets a new price oracle for the comptroller
<       * @dev Admin function to set a new price oracle
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setPriceOracle(PriceOracle newOracle) public returns (uint) {
---
>      * @notice Add a RewardsDistributor contracts.
>      * @dev Admin function to add a RewardsDistributor contract
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _addRewardsDistributor(address distributor)
>         external
>         returns (uint256)
>     {
826,827c1219,1342
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK
>                 );
>         }
> 
>         // Check marker method
>         require(
>             RewardsDistributorDelegate(distributor).isRewardsDistributor(),
>             "marker method returned false"
>         );
> 
>         // Check for existing RewardsDistributor
>         for (uint256 i = 0; i < rewardsDistributors.length; i++)
>             require(
>                 distributor != rewardsDistributors[i],
>                 "RewardsDistributor contract already added"
>             );
> 
>         // Add RewardsDistributor to array
>         rewardsDistributors.push(distributor);
>         emit AddedRewardsDistributor(distributor);
> 
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice Sets the whitelist enforcement for the comptroller
>      * @dev Admin function to set a new whitelist enforcement boolean
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setWhitelistEnforcement(bool enforce) external returns (uint256) {
>         // Check caller is admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK
>                 );
>         }
> 
>         // Check if `enforceWhitelist` already equals `enforce`
>         if (enforceWhitelist == enforce) {
>             return uint256(Error.NO_ERROR);
>         }
> 
>         // Set comptroller's `enforceWhitelist` to `enforce`
>         enforceWhitelist = enforce;
> 
>         // Emit WhitelistEnforcementChanged(bool enforce);
>         emit WhitelistEnforcementChanged(enforce);
> 
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice Sets the whitelist `statuses` for `suppliers`
>      * @dev Admin function to set the whitelist `statuses` for `suppliers`
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setWhitelistStatuses(
>         address[] calldata suppliers,
>         bool[] calldata statuses
>     ) external returns (uint256) {
>         // Check caller is admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK
>                 );
>         }
> 
>         // Set whitelist statuses for suppliers
>         for (uint256 i = 0; i < suppliers.length; i++) {
>             address supplier = suppliers[i];
> 
>             if (statuses[i]) {
>                 // If not already whitelisted, add to whitelist
>                 if (!whitelist[supplier]) {
>                     whitelist[supplier] = true;
>                     whitelistArray.push(supplier);
>                     whitelistIndexes[supplier] = whitelistArray.length - 1;
>                 }
>             } else {
>                 // If whitelisted, remove from whitelist
>                 if (whitelist[supplier]) {
>                     uint256 supplierIndex = whitelistIndexes[supplier];
> 
>                     // If supplier not at the end of the whitelist array, replace it with the item at the end of the whitelist array
>                     if (supplierIndex < whitelistArray.length - 1) {
>                         address lastElement = whitelistArray[
>                             whitelistArray.length - 1
>                         ];
>                         whitelistArray[supplierIndex] = lastElement; // Copy last item in list to location of item to be removed
>                         whitelistIndexes[lastElement] = supplierIndex; // Set whitelist index of moved item to correct index
>                     }
> 
>                     // Remove the last element of the whitelist array
>                     whitelistArray.length--; // Reduce length by 1
>                     whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund
>                     whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted
>                 }
>             }
>         }
> 
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice Sets a new price oracle for the comptroller
>      * @dev Admin function to set a new price oracle
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {
>         // Check caller is admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK
>                 );
839c1354
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
843,848c1358,1366
<       * @notice Sets the closeFactor used when liquidating borrows
<       * @dev Admin function to set closeFactor
<       * @param newCloseFactorMantissa New close factor, scaled by 1e18
<       * @return uint 0=success, otherwise a failure
<       */
<     function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {
---
>      * @notice Sets the closeFactor used when liquidating borrows
>      * @dev Admin function to set closeFactor
>      * @param newCloseFactorMantissa New close factor, scaled by 1e18
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setCloseFactor(uint256 newCloseFactorMantissa)
>         external
>         returns (uint256)
>     {
850c1368,1394
<     	require(msg.sender == admin, "only admin can set close factor");
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK
>                 );
>         }
> 
>         // Check limits
>         Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});
>         Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});
>         if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {
>             return
>                 fail(
>                     Error.INVALID_CLOSE_FACTOR,
>                     FailureInfo.SET_CLOSE_FACTOR_VALIDATION
>                 );
>         }
> 
>         Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});
>         if (lessThanExp(highLimit, newCloseFactorExp)) {
>             return
>                 fail(
>                     Error.INVALID_CLOSE_FACTOR,
>                     FailureInfo.SET_CLOSE_FACTOR_VALIDATION
>                 );
>         }
852c1396,1397
<         uint oldCloseFactorMantissa = closeFactorMantissa;
---
>         // Set pool close factor to new close factor, remember old value
>         uint256 oldCloseFactorMantissa = closeFactorMantissa;
853a1399,1400
> 
>         // Emit event
856c1403
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
860,866c1407,1416
<       * @notice Sets the collateralFactor for a market
<       * @dev Admin function to set per-market collateralFactor
<       * @param cToken The market to set the factor on
<       * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18
<       * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
<       */
<     function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {
---
>      * @notice Sets the collateralFactor for a market
>      * @dev Admin function to set per-market collateralFactor
>      * @param cToken The market to set the factor on
>      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setCollateralFactor(
>         CToken cToken,
>         uint256 newCollateralFactorMantissa
>     ) public returns (uint256) {
868,869c1418,1423
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK
>                 );
875c1429,1433
<             return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_LISTED,
>                     FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS
>                 );
878c1436,1438
<         Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});
---
>         Exp memory newCollateralFactorExp = Exp({
>             mantissa: newCollateralFactorMantissa
>         });
883c1443,1447
<             return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);
---
>             return
>                 fail(
>                     Error.INVALID_COLLATERAL_FACTOR,
>                     FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION
>                 );
887,888c1451,1459
<         if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {
<             return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);
---
>         if (
>             newCollateralFactorMantissa != 0 &&
>             oracle.getUnderlyingPrice(cToken) == 0
>         ) {
>             return
>                 fail(
>                     Error.PRICE_ERROR,
>                     FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE
>                 );
892c1463
<         uint oldCollateralFactorMantissa = market.collateralFactorMantissa;
---
>         uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;
896c1467,1471
<         emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);
---
>         emit NewCollateralFactor(
>             cToken,
>             oldCollateralFactorMantissa,
>             newCollateralFactorMantissa
>         );
898c1473
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
902,907c1477,1485
<       * @notice Sets liquidationIncentive
<       * @dev Admin function to set liquidationIncentive
<       * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18
<       * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
<       */
<     function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {
---
>      * @notice Sets liquidationIncentive
>      * @dev Admin function to set liquidationIncentive
>      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18
>      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
>      */
>     function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)
>         external
>         returns (uint256)
>     {
909,910c1487,1518
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK
>                 );
>         }
> 
>         // Check de-scaled min <= newLiquidationIncentive <= max
>         Exp memory newLiquidationIncentive = Exp({
>             mantissa: newLiquidationIncentiveMantissa
>         });
>         Exp memory minLiquidationIncentive = Exp({
>             mantissa: liquidationIncentiveMinMantissa
>         });
>         if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {
>             return
>                 fail(
>                     Error.INVALID_LIQUIDATION_INCENTIVE,
>                     FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION
>                 );
>         }
> 
>         Exp memory maxLiquidationIncentive = Exp({
>             mantissa: liquidationIncentiveMaxMantissa
>         });
>         if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {
>             return
>                 fail(
>                     Error.INVALID_LIQUIDATION_INCENTIVE,
>                     FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION
>                 );
914c1522
<         uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;
---
>         uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;
920c1528,1531
<         emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);
---
>         emit NewLiquidationIncentive(
>             oldLiquidationIncentiveMantissa,
>             newLiquidationIncentiveMantissa
>         );
922c1533
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
926,933c1537,1549
<       * @notice Add the market to the markets mapping and set it as listed
<       * @dev Admin function to set isListed and add support for the market
<       * @param cToken The address of the market (token) to list
<       * @return uint 0=success, otherwise a failure. (See enum Error for details)
<       */
<     function _supportMarket(CToken cToken) external returns (uint) {
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);
---
>      * @notice Add the market to the markets mapping and set it as listed
>      * @dev Admin function to set isListed and add support for the market
>      * @param cToken The address of the market (token) to list
>      * @return uint 0=success, otherwise a failure. (See enum Error for details)
>      */
>     function _supportMarket(CToken cToken) internal returns (uint256) {
>         // Check caller is admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SUPPORT_MARKET_OWNER_CHECK
>                 );
935a1552
>         // Is market already listed?
937,938c1554,1590
<             return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);
<         }
---
>             return
>                 fail(
>                     Error.MARKET_ALREADY_LISTED,
>                     FailureInfo.SUPPORT_MARKET_EXISTS
>                 );
>         }
> 
>         // Sanity check to make sure its really a CToken
>         require(cToken.isCToken(), "marker method returned false");
> 
>         // Check cToken.comptroller == this
>         require(
>             address(cToken.comptroller()) == address(this),
>             "Cannot support a market with a different Comptroller."
>         );
> 
>         // Make sure market is not already listed
>         address underlying = cToken.isCEther()
>             ? address(0)
>             : CErc20(address(cToken)).underlying();
> 
>         if (address(cTokensByUnderlying[underlying]) != address(0)) {
>             return
>                 fail(
>                     Error.MARKET_ALREADY_LISTED,
>                     FailureInfo.SUPPORT_MARKET_EXISTS
>                 );
>         }
> 
>         // List market and emit event
>         markets[address(cToken)] = Market({
>             isListed: true,
>             collateralFactorMantissa: 0
>         });
>         allMarkets.push(cToken);
>         cTokensByUnderlying[underlying] = cToken;
>         emit MarketListed(cToken);
940c1592,1593
<         cToken.isCToken(); // Sanity check to make sure its really a CToken
---
>         return uint256(Error.NO_ERROR);
>     }
942,943c1595,1623
<         // Note that isComped is not in active use anymore
<         markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});
---
>     /**
>      * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor
>      * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor
>      * @return uint 0=success, otherwise a failure. (See enum Error for details)
>      */
>     function _deployMarket(
>         bool isCEther,
>         bytes calldata constructorData,
>         uint256 collateralFactorMantissa
>     ) external returns (uint256) {
>         // Check caller is admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SUPPORT_MARKET_OWNER_CHECK
>                 );
>         }
> 
>         // Temporarily enable Fuse admin rights for asset deployment (storing the original value)
>         bool oldFuseAdminHasRights = fuseAdminHasRights;
>         fuseAdminHasRights = true;
> 
>         // Deploy via Fuse admin
>         CToken cToken = CToken(
>             isCEther
>                 ? fuseAdmin.deployCEther(constructorData)
>                 : fuseAdmin.deployCErc20(constructorData)
>         );
945,946c1625,1626
<         _addMarketInternal(address(cToken));
<         _initializeMarket(address(cToken));
---
>         // Reset Fuse admin rights to the original value
>         fuseAdminHasRights = oldFuseAdminHasRights;
948c1628,1629
<         emit MarketListed(cToken);
---
>         // Support market here in the Comptroller
>         uint256 err = _supportMarket(cToken);
950c1631,1635
<         return uint(Error.NO_ERROR);
---
>         // Set collateral factor
>         return
>             err == uint256(Error.NO_ERROR)
>                 ? _setCollateralFactor(cToken, collateralFactorMantissa)
>                 : err;
953,955c1638,1681
<     function _addMarketInternal(address cToken) internal {
<         for (uint i = 0; i < allMarkets.length; i ++) {
<             require(allMarkets[i] != CToken(cToken), "market already added");
---
>     /**
>      * @notice Removed a market from the markets mapping and sets it as unlisted
>      * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market
>      * @param cToken The address of the market (token) to unlist
>      * @return uint 0=success, otherwise a failure. (See enum Error for details)
>      */
>     function _unsupportMarket(CToken cToken) external returns (uint256) {
>         // Check admin rights
>         if (!hasAdminRights())
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK
>                 );
> 
>         // Check if market is already unlisted
>         if (!markets[address(cToken)].isListed)
>             return
>                 fail(
>                     Error.MARKET_NOT_LISTED,
>                     FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST
>                 );
> 
>         // Check if market is in use
>         if (cToken.totalSupply() > 0)
>             return
>                 fail(
>                     Error.NONZERO_TOTAL_SUPPLY,
>                     FailureInfo.UNSUPPORT_MARKET_IN_USE
>                 );
> 
>         // Unlist market
>         delete markets[address(cToken)];
> 
>         /* Delete cToken from allMarkets */
>         // load into memory for faster iteration
>         CToken[] memory _allMarkets = allMarkets;
>         uint256 len = _allMarkets.length;
>         uint256 assetIndex = len;
>         for (uint256 i = 0; i < len; i++) {
>             if (_allMarkets[i] == cToken) {
>                 assetIndex = i;
>                 break;
>             }
957,958d1682
<         allMarkets.push(CToken(cToken));
<     }
960,961c1684,1689
<     function _initializeMarket(address cToken) internal {
<         uint32 blockNumber = safe32(getBlockNumber(), "block number exceeds 32 bits");
---
>         // We *must* have found the asset in the list or our redundant data structure is broken
>         assert(assetIndex < len);
> 
>         // copy last item in list to location of item to be removed, reduce length by 1
>         allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];
>         allMarkets.length--;
963,964c1691,1696
<         CompMarketState storage supplyState = compSupplyState[cToken];
<         CompMarketState storage borrowState = compBorrowState[cToken];
---
>         cTokensByUnderlying[
>             cToken.isCEther()
>                 ? address(0)
>                 : CErc20(address(cToken)).underlying()
>         ] = CToken(address(0));
>         emit MarketUnlisted(cToken);
966,972c1698,1699
<         /*
<          * Update market state indices
<          */
<         if (supplyState.index == 0) {
<             // Initialize supply state index with default value
<             supplyState.index = compInitialIndex;
<         }
---
>         return uint256(Error.NO_ERROR);
>     }
974,976c1701,1712
<         if (borrowState.index == 0) {
<             // Initialize borrow state index with default value
<             borrowState.index = compInitialIndex;
---
>     /**
>      * @notice Toggles the auto-implementation feature
>      * @param enabled If the feature is to be enabled
>      * @return uint 0=success, otherwise a failure. (See enum Error for details)
>      */
>     function _toggleAutoImplementations(bool enabled) public returns (uint256) {
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK
>                 );
979,982c1715,1724
<         /*
<          * Update market state block numbers
<          */
<          supplyState.block = borrowState.block = blockNumber;
---
>         // Return no error if already set to the desired value
>         if (autoImplementation == enabled) return uint256(Error.NO_ERROR);
> 
>         // Store autoImplementation with value enabled
>         autoImplementation = enabled;
> 
>         // Emit AutoImplementationsToggled(enabled)
>         emit AutoImplementationsToggled(enabled);
> 
>         return uint256(Error.NO_ERROR);
984a1727,1754
>     /**
>      * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.
>      * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.
>      * @param cTokens The addresses of the markets (tokens) to change the supply caps for
>      * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.
>      */
>     function _setMarketSupplyCaps(
>         CToken[] calldata cTokens,
>         uint256[] calldata newSupplyCaps
>     ) external {
>         require(
>             hasAdminRights() || msg.sender == borrowCapGuardian,
>             "only admin or borrow cap guardian can set supply caps"
>         );
> 
>         uint256 numMarkets = cTokens.length;
>         uint256 numSupplyCaps = newSupplyCaps.length;
> 
>         require(
>             numMarkets != 0 && numMarkets == numSupplyCaps,
>             "invalid input"
>         );
> 
>         for (uint256 i = 0; i < numMarkets; i++) {
>             supplyCaps[address(cTokens[i])] = newSupplyCaps[i];
>             emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);
>         }
>     }
987,993c1757,1769
<       * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.
<       * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.
<       * @param cTokens The addresses of the markets (tokens) to change the borrow caps for
<       * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.
<       */
<     function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {
<     	require(msg.sender == admin || msg.sender == borrowCapGuardian, "only admin or borrow cap guardian can set borrow caps"); 
---
>      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.
>      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.
>      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for
>      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.
>      */
>     function _setMarketBorrowCaps(
>         CToken[] calldata cTokens,
>         uint256[] calldata newBorrowCaps
>     ) external {
>         require(
>             hasAdminRights() || msg.sender == borrowCapGuardian,
>             "only admin or borrow cap guardian can set borrow caps"
>         );
995,996c1771,1772
<         uint numMarkets = cTokens.length;
<         uint numBorrowCaps = newBorrowCaps.length;
---
>         uint256 numMarkets = cTokens.length;
>         uint256 numBorrowCaps = newBorrowCaps.length;
998c1774,1777
<         require(numMarkets != 0 && numMarkets == numBorrowCaps, "invalid input");
---
>         require(
>             numMarkets != 0 && numMarkets == numBorrowCaps,
>             "invalid input"
>         );
1000c1779
<         for(uint i = 0; i < numMarkets; i++) {
---
>         for (uint256 i = 0; i < numMarkets; i++) {
1011c1790
<         require(msg.sender == admin, "only admin can set borrow cap guardian");
---
>         require(hasAdminRights(), "only admin can set borrow cap guardian");
1028,1030c1807,1816
<     function _setPauseGuardian(address newPauseGuardian) public returns (uint) {
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);
---
>     function _setPauseGuardian(address newPauseGuardian)
>         public
>         returns (uint256)
>     {
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK
>                 );
1042c1828
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
1046,1048c1832,1840
<         require(markets[address(cToken)].isListed, "cannot pause a market that is not listed");
<         require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");
<         require(msg.sender == admin || state == true, "only admin can unpause");
---
>         require(
>             markets[address(cToken)].isListed,
>             "cannot pause a market that is not listed"
>         );
>         require(
>             msg.sender == pauseGuardian || hasAdminRights(),
>             "only pause guardian and admin can pause"
>         );
>         require(hasAdminRights() || state == true, "only admin can unpause");
1056,1058c1848,1856
<         require(markets[address(cToken)].isListed, "cannot pause a market that is not listed");
<         require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");
<         require(msg.sender == admin || state == true, "only admin can unpause");
---
>         require(
>             markets[address(cToken)].isListed,
>             "cannot pause a market that is not listed"
>         );
>         require(
>             msg.sender == pauseGuardian || hasAdminRights(),
>             "only pause guardian and admin can pause"
>         );
>         require(hasAdminRights() || state == true, "only admin can unpause");
1066,1067c1864,1868
<         require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");
<         require(msg.sender == admin || state == true, "only admin can unpause");
---
>         require(
>             msg.sender == pauseGuardian || hasAdminRights(),
>             "only pause guardian and admin can pause"
>         );
>         require(hasAdminRights() || state == true, "only admin can unpause");
1075,1076c1876,1880
<         require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");
<         require(msg.sender == admin || state == true, "only admin can unpause");
---
>         require(
>             msg.sender == pauseGuardian || hasAdminRights(),
>             "only pause guardian and admin can pause"
>         );
>         require(hasAdminRights() || state == true, "only admin can unpause");
1084,1243c1888,1894
<         require(msg.sender == unitroller.admin(), "only unitroller admin can change brains");
<         require(unitroller._acceptImplementation() == 0, "change not authorized");
<     }
< 
<     /// @notice Delete this function after proposal 65 is executed
<     function fixBadAccruals(address[] calldata affectedUsers, uint[] calldata amounts) external {
<         require(msg.sender == admin, "Only admin can call this function"); // Only the timelock can call this function
<         require(!proposal65FixExecuted, "Already executed this one-off function"); // Require that this function is only called once
<         require(affectedUsers.length == amounts.length, "Invalid input");
< 
<         // Loop variables
<         address user;
<         uint currentAccrual;
<         uint amountToSubtract;
<         uint newAccrual;
< 
<         // Iterate through all affected users
<         for (uint i = 0; i < affectedUsers.length; ++i) {
<             user = affectedUsers[i];
<             currentAccrual = compAccrued[user];
< 
<             amountToSubtract = amounts[i];
< 
<             // The case where the user has claimed and received an incorrect amount of COMP.
<             // The user has less currently accrued than the amount they incorrectly received.
<             if (amountToSubtract > currentAccrual) {
<                 // Amount of COMP the user owes the protocol
<                 uint accountReceivable = amountToSubtract - currentAccrual; // Underflow safe since amountToSubtract > currentAccrual
< 
<                 uint oldReceivable = compReceivable[user];
<                 uint newReceivable = add_(oldReceivable, accountReceivable);
< 
<                 // Accounting: record the COMP debt for the user
<                 compReceivable[user] = newReceivable;
< 
<                 emit CompReceivableUpdated(user, oldReceivable, newReceivable);
< 
<                 amountToSubtract = currentAccrual;
<             }
<             
<             if (amountToSubtract > 0) {
<                 // Subtract the bad accrual amount from what they have accrued.
<                 // Users will keep whatever they have correctly accrued.
<                 compAccrued[user] = newAccrual = sub_(currentAccrual, amountToSubtract);
< 
<                 emit CompAccruedAdjusted(user, currentAccrual, newAccrual);
<             }
<         }
< 
<         proposal65FixExecuted = true; // Makes it so that this function cannot be called again
<     }
< 
<     /**
<      * @notice Checks caller is admin, or this contract is becoming the new implementation
<      */
<     function adminOrInitializing() internal view returns (bool) {
<         return msg.sender == admin || msg.sender == comptrollerImplementation;
<     }
< 
<     /*** Comp Distribution ***/
< 
<     /**
<      * @notice Set COMP speed for a single market
<      * @param cToken The market whose COMP speed to update
<      * @param supplySpeed New supply-side COMP speed for market
<      * @param borrowSpeed New borrow-side COMP speed for market
<      */
<     function setCompSpeedInternal(CToken cToken, uint supplySpeed, uint borrowSpeed) internal {
<         Market storage market = markets[address(cToken)];
<         require(market.isListed, "comp market is not listed");
< 
<         if (compSupplySpeeds[address(cToken)] != supplySpeed) {
<             // Supply speed updated so let's update supply state to ensure that
<             //  1. COMP accrued properly for the old speed, and
<             //  2. COMP accrued at the new speed starts after this block.
<             updateCompSupplyIndex(address(cToken));
< 
<             // Update speed and emit event
<             compSupplySpeeds[address(cToken)] = supplySpeed;
<             emit CompSupplySpeedUpdated(cToken, supplySpeed);
<         }
< 
<         if (compBorrowSpeeds[address(cToken)] != borrowSpeed) {
<             // Borrow speed updated so let's update borrow state to ensure that
<             //  1. COMP accrued properly for the old speed, and
<             //  2. COMP accrued at the new speed starts after this block.
<             Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
<             updateCompBorrowIndex(address(cToken), borrowIndex);
< 
<             // Update speed and emit event
<             compBorrowSpeeds[address(cToken)] = borrowSpeed;
<             emit CompBorrowSpeedUpdated(cToken, borrowSpeed);
<         }
<     }
< 
<     /**
<      * @notice Accrue COMP to the market by updating the supply index
<      * @param cToken The market whose supply index to update
<      * @dev Index is a cumulative sum of the COMP per cToken accrued.
<      */
<     function updateCompSupplyIndex(address cToken) internal {
<         CompMarketState storage supplyState = compSupplyState[cToken];
<         uint supplySpeed = compSupplySpeeds[cToken];
<         uint32 blockNumber = safe32(getBlockNumber(), "block number exceeds 32 bits");
<         uint deltaBlocks = sub_(uint(blockNumber), uint(supplyState.block));
<         if (deltaBlocks > 0 && supplySpeed > 0) {
<             uint supplyTokens = CToken(cToken).totalSupply();
<             uint compAccrued = mul_(deltaBlocks, supplySpeed);
<             Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});
<             supplyState.index = safe224(add_(Double({mantissa: supplyState.index}), ratio).mantissa, "new index exceeds 224 bits");
<             supplyState.block = blockNumber;
<         } else if (deltaBlocks > 0) {
<             supplyState.block = blockNumber;
<         }
<     }
< 
<     /**
<      * @notice Accrue COMP to the market by updating the borrow index
<      * @param cToken The market whose borrow index to update
<      * @dev Index is a cumulative sum of the COMP per cToken accrued.
<      */
<     function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {
<         CompMarketState storage borrowState = compBorrowState[cToken];
<         uint borrowSpeed = compBorrowSpeeds[cToken];
<         uint32 blockNumber = safe32(getBlockNumber(), "block number exceeds 32 bits");
<         uint deltaBlocks = sub_(uint(blockNumber), uint(borrowState.block));
<         if (deltaBlocks > 0 && borrowSpeed > 0) {
<             uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);
<             uint compAccrued = mul_(deltaBlocks, borrowSpeed);
<             Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});
<             borrowState.index = safe224(add_(Double({mantissa: borrowState.index}), ratio).mantissa, "new index exceeds 224 bits");
<             borrowState.block = blockNumber;
<         } else if (deltaBlocks > 0) {
<             borrowState.block = blockNumber;
<         }
<     }
< 
<     /**
<      * @notice Calculate COMP accrued by a supplier and possibly transfer it to them
<      * @param cToken The market in which the supplier is interacting
<      * @param supplier The address of the supplier to distribute COMP to
<      */
<     function distributeSupplierComp(address cToken, address supplier) internal {
<         // TODO: Don't distribute supplier COMP if the user is not in the supplier market.
<         // This check should be as gas efficient as possible as distributeSupplierComp is called in many places.
<         // - We really don't want to call an external contract as that's quite expensive.
< 
<         CompMarketState storage supplyState = compSupplyState[cToken];
<         uint supplyIndex = supplyState.index;
<         uint supplierIndex = compSupplierIndex[cToken][supplier];
< 
<         // Update supplier's index to the current index since we are distributing accrued COMP
<         compSupplierIndex[cToken][supplier] = supplyIndex;
< 
<         if (supplierIndex == 0 && supplyIndex >= compInitialIndex) {
<             // Covers the case where users supplied tokens before the market's supply state index was set.
<             // Rewards the user with COMP accrued from the start of when supplier rewards were first
<             // set for the market.
<             supplierIndex = compInitialIndex;
<         }
---
>         require(
>             (msg.sender == address(fuseAdmin) &&
>                 unitroller.fuseAdminHasRights()) ||
>                 (msg.sender == unitroller.admin() &&
>                     unitroller.adminHasRights()),
>             "only unitroller admin can change brains"
>         );
1245,1246c1896,1897
<         // Calculate change in the cumulative sum of the COMP per cToken accrued
<         Double memory deltaIndex = Double({mantissa: sub_(supplyIndex, supplierIndex)});
---
>         uint256 changeStatus = unitroller._acceptImplementation();
>         require(changeStatus == 0, "change not authorized");
1248,1256c1899
<         uint supplierTokens = CToken(cToken).balanceOf(supplier);
< 
<         // Calculate COMP accrued: cTokenAmount * accruedPerCToken
<         uint supplierDelta = mul_(supplierTokens, deltaIndex);
< 
<         uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);
<         compAccrued[supplier] = supplierAccrued;
< 
<         emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex);
---
>         Comptroller(address(unitroller))._becomeImplementation();
1259,1272c1902,1906
<     /**
<      * @notice Calculate COMP accrued by a borrower and possibly transfer it to them
<      * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.
<      * @param cToken The market in which the borrower is interacting
<      * @param borrower The address of the borrower to distribute COMP to
<      */
<     function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex) internal {
<         // TODO: Don't distribute supplier COMP if the user is not in the borrower market.
<         // This check should be as gas efficient as possible as distributeBorrowerComp is called in many places.
<         // - We really don't want to call an external contract as that's quite expensive.
< 
<         CompMarketState storage borrowState = compBorrowState[cToken];
<         uint borrowIndex = borrowState.index;
<         uint borrowerIndex = compBorrowerIndex[cToken][borrower];
---
>     function _becomeImplementation() external {
>         require(
>             msg.sender == comptrollerImplementation,
>             "only implementation may call _becomeImplementation"
>         );
1274,1281c1908,1910
<         // Update borrowers's index to the current index since we are distributing accrued COMP
<         compBorrowerIndex[cToken][borrower] = borrowIndex;
< 
<         if (borrowerIndex == 0 && borrowIndex >= compInitialIndex) {
<             // Covers the case where users borrowed tokens before the market's borrow state index was set.
<             // Rewards the user with COMP accrued from the start of when borrower rewards were first
<             // set for the market.
<             borrowerIndex = compInitialIndex;
---
>         if (!_notEnteredInitialized) {
>             _notEntered = true;
>             _notEnteredInitialized = true;
1283,1295d1911
< 
<         // Calculate change in the cumulative sum of the COMP per borrowed unit accrued
<         Double memory deltaIndex = Double({mantissa: sub_(borrowIndex, borrowerIndex)});
< 
<         uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);
<         
<         // Calculate COMP accrued: cTokenAmount * accruedPerBorrowedUnit
<         uint borrowerDelta = mul_(borrowerAmount, deltaIndex);
< 
<         uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);
<         compAccrued[borrower] = borrowerAccrued;
< 
<         emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex);
1298,1321c1914
<     /**
<      * @notice Calculate additional accrued COMP for a contributor since last accrual
<      * @param contributor The address to calculate contributor rewards for
<      */
<     function updateContributorRewards(address contributor) public {
<         uint compSpeed = compContributorSpeeds[contributor];
<         uint blockNumber = getBlockNumber();
<         uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);
<         if (deltaBlocks > 0 && compSpeed > 0) {
<             uint newAccrued = mul_(deltaBlocks, compSpeed);
<             uint contributorAccrued = add_(compAccrued[contributor], newAccrued);
< 
<             compAccrued[contributor] = contributorAccrued;
<             lastContributorBlock[contributor] = blockNumber;
<         }
<     }
< 
<     /**
<      * @notice Claim all the comp accrued by holder in all markets
<      * @param holder The address to claim COMP for
<      */
<     function claimComp(address holder) public {
<         return claimComp(holder, allMarkets);
<     }
---
>     /*** Helper Functions ***/
1324,1387c1917,1919
<      * @notice Claim all the comp accrued by holder in the specified markets
<      * @param holder The address to claim COMP for
<      * @param cTokens The list of markets to claim COMP in
<      */
<     function claimComp(address holder, CToken[] memory cTokens) public {
<         address[] memory holders = new address[](1);
<         holders[0] = holder;
<         claimComp(holders, cTokens, true, true);
<     }
< 
<     /**
<      * @notice Claim all comp accrued by the holders
<      * @param holders The addresses to claim COMP for
<      * @param cTokens The list of markets to claim COMP in
<      * @param borrowers Whether or not to claim COMP earned by borrowing
<      * @param suppliers Whether or not to claim COMP earned by supplying
<      */
<     function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
<         for (uint i = 0; i < cTokens.length; i++) {
<             CToken cToken = cTokens[i];
<             require(markets[address(cToken)].isListed, "market must be listed");
<             if (borrowers == true) {
<                 Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
<                 updateCompBorrowIndex(address(cToken), borrowIndex);
<                 for (uint j = 0; j < holders.length; j++) {
<                     distributeBorrowerComp(address(cToken), holders[j], borrowIndex);
<                 }
<             }
<             if (suppliers == true) {
<                 updateCompSupplyIndex(address(cToken));
<                 for (uint j = 0; j < holders.length; j++) {
<                     distributeSupplierComp(address(cToken), holders[j]);
<                 }
<             }
<         }
<         for (uint j = 0; j < holders.length; j++) {
<             compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);
<         }
<     }
< 
<     /**
<      * @notice Transfer COMP to the user
<      * @dev Note: If there is not enough COMP, we do not perform the transfer all.
<      * @param user The address of the user to transfer COMP to
<      * @param amount The amount of COMP to (possibly) transfer
<      * @return The amount of COMP which was NOT transferred to the user
<      */
<     function grantCompInternal(address user, uint amount) internal returns (uint) {
<         Comp comp = Comp(getCompAddress());
<         uint compRemaining = comp.balanceOf(address(this));
<         if (amount > 0 && amount <= compRemaining) {
<             comp.transfer(user, amount);
<             return 0;
<         }
<         return amount;
<     }
< 
<     /*** Comp Distribution Admin ***/
< 
<     /**
<      * @notice Transfer COMP to the recipient
<      * @dev Note: If there is not enough COMP, we do not perform the transfer all.
<      * @param recipient The address of the recipient to transfer COMP to
<      * @param amount The amount of COMP to (possibly) transfer
---
>      * @notice Return all of the markets
>      * @dev The automatic getter may be used to access an individual market.
>      * @return The list of market addresses
1389,1393c1921,1922
<     function _grantComp(address recipient, uint amount) public {
<         require(adminOrInitializing(), "only admin can grant comp");
<         uint amountLeft = grantCompInternal(recipient, amount);
<         require(amountLeft == 0, "insufficient comp for grant");
<         emit CompGranted(recipient, amount);
---
>     function getAllMarkets() public view returns (CToken[] memory) {
>         return allMarkets;
1397,1400c1926,1928
<      * @notice Set COMP borrow and supply speeds for the specified markets.
<      * @param cTokens The markets whose COMP speed to update.
<      * @param supplySpeeds New supply-side COMP speed for the corresponding market.
<      * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.
---
>      * @notice Return all of the borrowers
>      * @dev The automatic getter may be used to access an individual borrower.
>      * @return The list of borrower account addresses
1402,1410c1930,1931
<     function _setCompSpeeds(CToken[] memory cTokens, uint[] memory supplySpeeds, uint[] memory borrowSpeeds) public {
<         require(adminOrInitializing(), "only admin can set comp speed");
< 
<         uint numTokens = cTokens.length;
<         require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, "Comptroller::_setCompSpeeds invalid input");
< 
<         for (uint i = 0; i < numTokens; ++i) {
<             setCompSpeedInternal(cTokens[i], supplySpeeds[i], borrowSpeeds[i]);
<         }
---
>     function getAllBorrowers() public view returns (address[] memory) {
>         return allBorrowers;
1414,1416c1935,1937
<      * @notice Set COMP speed for a single contributor
<      * @param contributor The contributor whose COMP speed to update
<      * @param compSpeed New COMP speed for contributor
---
>      * @notice Return all of the whitelist
>      * @dev The automatic getter may be used to access an individual whitelist status.
>      * @return The list of borrower account addresses
1418,1431c1939,1940
<     function _setContributorCompSpeed(address contributor, uint compSpeed) public {
<         require(adminOrInitializing(), "only admin can set comp speed");
< 
<         // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor
<         updateContributorRewards(contributor);
<         if (compSpeed == 0) {
<             // release storage
<             delete lastContributorBlock[contributor];
<         } else {
<             lastContributorBlock[contributor] = getBlockNumber();
<         }
<         compContributorSpeeds[contributor] = compSpeed;
< 
<         emit ContributorCompSpeedUpdated(contributor, compSpeed);
---
>     function getWhitelist() external view returns (address[] memory) {
>         return whitelistArray;
1435,1437c1944
<      * @notice Return all of the markets
<      * @dev The automatic getter may be used to access an individual market.
<      * @return The list of market addresses
---
>      * @notice Returns an array of all RewardsDistributors
1439,1440c1946,1947
<     function getAllMarkets() public view returns (CToken[] memory) {
<         return allMarkets;
---
>     function getRewardsDistributors() external view returns (address[] memory) {
>         return rewardsDistributors;
1450,1453c1957,1963
<             markets[address(cToken)].collateralFactorMantissa == 0 && 
<             borrowGuardianPaused[address(cToken)] == true && 
<             cToken.reserveFactorMantissa() == 1e18
<         ;
---
>             markets[address(cToken)].collateralFactorMantissa == 0 &&
>             borrowGuardianPaused[address(cToken)] == true &&
>             add_(
>                 add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()),
>                 cToken.fuseFeeMantissa()
>             ) ==
>             1e18;
1456,1457c1966,1978
<     function getBlockNumber() public view returns (uint) {
<         return block.number;
---
>     /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/
> 
>     /**
>      * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.
>      * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.
>      */
>     function _beforeNonReentrant() external {
>         require(
>             markets[msg.sender].isListed,
>             "Comptroller:_beforeNonReentrant: caller not listed as market"
>         );
>         require(_notEntered, "re-entered across assets");
>         _notEntered = false;
1461,1462c1982,1983
<      * @notice Return the address of the COMP token
<      * @return The address of COMP
---
>      * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.
>      * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.
1464,1465c1985,1990
<     function getCompAddress() public view returns (address) {
<         return 0xc00e94Cb662C3520282E6f5717214004A7f26888;
---
>     function _afterNonReentrant() external {
>         require(
>             markets[msg.sender].isListed,
>             "Comptroller:_afterNonReentrant: caller not listed as market"
>         );
>         _notEntered = true; // get a gas-refund post-Istanbul
diff -x .git -r ../compound-protocol/contracts/ComptrollerStorage.sol src/core/ComptrollerStorage.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
2a3
> import "./IFuseFeeDistributor.sol";
8,9c9,16
<     * @notice Administrator for this contract
<     */
---
>      * @notice Administrator for Fuse
>      */
>     IFuseFeeDistributor internal constant fuseAdmin =
>         IFuseFeeDistributor(0xa731585ab05fC9f83555cf9Bff8F58ee94e18F85);
> 
>     /**
>      * @notice Administrator for this contract
>      */
13,14c20,21
<     * @notice Pending administrator for this contract
<     */
---
>      * @notice Pending administrator for this contract
>      */
18,19c25,45
<     * @notice Active brains of Unitroller
<     */
---
>      * @notice Whether or not the Fuse admin has admin rights
>      */
>     bool public fuseAdminHasRights = true;
> 
>     /**
>      * @notice Whether or not the admin has admin rights
>      */
>     bool public adminHasRights = true;
> 
>     /**
>      * @notice Returns a boolean indicating if the sender has admin rights
>      */
>     function hasAdminRights() internal view returns (bool) {
>         return
>             (msg.sender == admin && adminHasRights) ||
>             (msg.sender == address(fuseAdmin) && fuseAdminHasRights);
>     }
> 
>     /**
>      * @notice Active brains of Unitroller
>      */
23,24c49,50
<     * @notice Pending brains of Unitroller
<     */
---
>      * @notice Pending brains of Unitroller
>      */
29d54
< 
38c63
<     uint public closeFactorMantissa;
---
>     uint256 public closeFactorMantissa;
43c68
<     uint public liquidationIncentiveMantissa;
---
>     uint256 public liquidationIncentiveMantissa;
46c71
<      * @notice Max number of assets a single account can participate in (borrow or use as collateral)
---
>      * @notice UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)
48c73
<     uint public maxAssets;
---
>     uint256 internal maxAssets;
54d78
< 
59c83,85
<         /// @notice Whether or not this market is listed
---
>         /**
>          * @notice Whether or not this market is listed
>          */
61d86
< 
67,69c92,95
<         uint collateralFactorMantissa;
< 
<         /// @notice Per-market mapping of "accounts in this asset"
---
>         uint256 collateralFactorMantissa;
>         /**
>          * @notice Per-market mapping of "accounts in this asset"
>          */
71,73d96
< 
<         /// @notice Whether or not this market receives COMP
<         bool isComped;
81a105,137
>     /// @notice A list of all markets
>     CToken[] public allMarkets;
> 
>     /**
>      * @dev Maps borrowers to booleans indicating if they have entered any markets
>      */
>     mapping(address => bool) internal borrowers;
> 
>     /// @notice A list of all borrowers who have entered markets
>     address[] public allBorrowers;
> 
>     /// @notice Indexes of borrower account addresses in the `allBorrowers` array
>     mapping(address => uint256) internal borrowerIndexes;
> 
>     /**
>      * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets
>      */
>     mapping(address => bool) public suppliers;
> 
>     /// @notice All cTokens addresses mapped by their underlying token addresses
>     mapping(address => CToken) public cTokensByUnderlying;
> 
>     /// @notice Whether or not the supplier whitelist is enforced
>     bool public enforceWhitelist;
> 
>     /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)
>     mapping(address => bool) public whitelist;
> 
>     /// @notice An array of all whitelisted accounts
>     address[] public whitelistArray;
> 
>     /// @notice Indexes of account addresses in the `whitelistArray` array
>     mapping(address => uint256) internal whitelistIndexes;
98,129c154,157
<     struct CompMarketState {
<         /// @notice The market's last updated compBorrowIndex or compSupplyIndex
<         uint224 index;
< 
<         /// @notice The block number the index was last updated at
<         uint32 block;
<     }
< 
<     /// @notice A list of all markets
<     CToken[] public allMarkets;
< 
<     /// @notice The rate at which the flywheel distributes COMP, per block
<     uint public compRate;
< 
<     /// @notice The portion of compRate that each market currently receives
<     mapping(address => uint) public compSpeeds;
< 
<     /// @notice The COMP market supply state for each market
<     mapping(address => CompMarketState) public compSupplyState;
< 
<     /// @notice The COMP market borrow state for each market
<     mapping(address => CompMarketState) public compBorrowState;
< 
<     /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP
<     mapping(address => mapping(address => uint)) public compSupplierIndex;
< 
<     /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP
<     mapping(address => mapping(address => uint)) public compBorrowerIndex;
< 
<     /// @notice The COMP accrued but not yet transferred to each user
<     mapping(address => uint) public compAccrued;
< }
---
>     /**
>      * @dev Whether or not the implementation should be auto-upgraded.
>      */
>     bool public autoImplementation;
131,132c159
< contract ComptrollerV4Storage is ComptrollerV3Storage {
<     // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.
---
>     /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.
135,137c162,163
<     // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.
<     mapping(address => uint) public borrowCaps;
< }
---
>     /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.
>     mapping(address => uint256) public borrowCaps;
139,141c165,166
< contract ComptrollerV5Storage is ComptrollerV4Storage {
<     /// @notice The portion of COMP that each contributor receives per block
<     mapping(address => uint) public compContributorSpeeds;
---
>     /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.
>     mapping(address => uint256) public supplyCaps;
143,153c168,169
<     /// @notice Last block at which a contributor's COMP rewards have been allocated
<     mapping(address => uint) public lastContributorBlock;
< }
< 
< contract ComptrollerV6Storage is ComptrollerV5Storage {
<     /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)
<     mapping(address => uint) public compBorrowSpeeds;
< 
<     /// @notice The rate at which comp is distributed to the corresponding supply market (per block)
<     mapping(address => uint) public compSupplySpeeds;
< }
---
>     /// @notice RewardsDistributor contracts to notify of flywheel changes.
>     address[] public rewardsDistributors;
155,157c171,172
< contract ComptrollerV7Storage is ComptrollerV6Storage {
<     /// @notice Flag indicating whether the function to fix COMP accruals has been executed (RE: proposal 62 bug)
<     bool public proposal65FixExecuted;
---
>     /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks
>     bool internal _notEntered;
159,160c174,175
<     /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.
<     mapping(address => uint) public compReceivable;
---
>     /// @dev Whether or not _notEntered has been initialized
>     bool internal _notEnteredInitialized;
diff -x .git -r ../compound-protocol/contracts/CTokenInterfaces.sol src/core/CTokenInterfaces.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
2a3,4
> import "./IFuseFeeDistributor.sol";
> import "./ComptrollerStorage.sol";
5d6
< import "./EIP20NonStandardInterface.sol";
7c8,31
< contract CTokenStorage {
---
> contract CTokenAdminStorage {
>     /**
>      * @notice Administrator for Fuse
>      */
>     IFuseFeeDistributor internal constant fuseAdmin =
>         IFuseFeeDistributor(0xa731585ab05fC9f83555cf9Bff8F58ee94e18F85);
> 
>     /**
>      * @dev LEGACY USE ONLY: Administrator for this contract
>      */
>     address payable internal __admin;
> 
>     /**
>      * @dev LEGACY USE ONLY: Whether or not the Fuse admin has admin rights
>      */
>     bool internal __fuseAdminHasRights;
> 
>     /**
>      * @dev LEGACY USE ONLY: Whether or not the admin has admin rights
>      */
>     bool internal __adminHasRights;
> }
> 
> contract CTokenStorage is CTokenAdminStorage {
31,32c55
< 
<     uint internal constant borrowRateMaxMantissa = 0.0005e16;
---
>     uint256 internal constant borrowRateMaxMantissa = 0.0005e16;
35c58
<      * @notice Maximum fraction of interest that can be set aside for reserves
---
>      * @notice Maximum fraction of interest that can be set aside for reserves + fees
37c60
<     uint internal constant reserveFactorMaxMantissa = 1e18;
---
>     uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;
40c63
<      * @notice Administrator for this contract
---
>      * @notice LEGACY USE ONLY: Pending administrator for this contract
42,47c65
<     address payable public admin;
< 
<     /**
<      * @notice Pending administrator for this contract
<      */
<     address payable public pendingAdmin;
---
>     address payable private __pendingAdmin;
62c80,90
<     uint internal initialExchangeRateMantissa;
---
>     uint256 internal initialExchangeRateMantissa;
> 
>     /**
>      * @notice Fraction of interest currently set aside for admin fees
>      */
>     uint256 public adminFeeMantissa;
> 
>     /**
>      * @notice Fraction of interest currently set aside for Fuse fees
>      */
>     uint256 public fuseFeeMantissa;
67c95
<     uint public reserveFactorMantissa;
---
>     uint256 public reserveFactorMantissa;
72c100
<     uint public accrualBlockNumber;
---
>     uint256 public accrualBlockNumber;
77c105
<     uint public borrowIndex;
---
>     uint256 public borrowIndex;
82c110
<     uint public totalBorrows;
---
>     uint256 public totalBorrows;
87c115,125
<     uint public totalReserves;
---
>     uint256 public totalReserves;
> 
>     /**
>      * @notice Total amount of admin fees of the underlying held in this market
>      */
>     uint256 public totalAdminFees;
> 
>     /**
>      * @notice Total amount of Fuse fees of the underlying held in this market
>      */
>     uint256 public totalFuseFees;
92c130
<     uint public totalSupply;
---
>     uint256 public totalSupply;
97c135
<     mapping (address => uint) internal accountTokens;
---
>     mapping(address => uint256) internal accountTokens;
102c140
<     mapping (address => mapping (address => uint)) internal transferAllowances;
---
>     mapping(address => mapping(address => uint256)) internal transferAllowances;
110,111c148,149
<         uint principal;
<         uint interestIndex;
---
>         uint256 principal;
>         uint256 interestIndex;
122,123c160
<     uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%
< 
---
>     uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%
131a169,172
>     /**
>      * @notice Indicator that this is or is not a CEther contract (for inspection)
>      */
>     bool public constant isCEther = false;
138c179,184
<     event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);
---
>     event AccrueInterest(
>         uint256 cashPrior,
>         uint256 interestAccumulated,
>         uint256 borrowIndex,
>         uint256 totalBorrows
>     );
143c189
<     event Mint(address minter, uint mintAmount, uint mintTokens);
---
>     event Mint(address minter, uint256 mintAmount, uint256 mintTokens);
148c194
<     event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);
---
>     event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);
153c199,204
<     event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);
---
>     event Borrow(
>         address borrower,
>         uint256 borrowAmount,
>         uint256 accountBorrows,
>         uint256 totalBorrows
>     );
158c209,215
<     event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);
---
>     event RepayBorrow(
>         address payer,
>         address borrower,
>         uint256 repayAmount,
>         uint256 accountBorrows,
>         uint256 totalBorrows
>     );
163,164c220,226
<     event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);
< 
---
>     event LiquidateBorrow(
>         address liquidator,
>         address borrower,
>         uint256 repayAmount,
>         address cTokenCollateral,
>         uint256 seizeTokens
>     );
169c231
<      * @notice Event emitted when pendingAdmin is changed
---
>      * @notice Event emitted when comptroller is changed
171c233,236
<     event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
---
>     event NewComptroller(
>         ComptrollerInterface oldComptroller,
>         ComptrollerInterface newComptroller
>     );
174c239
<      * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
---
>      * @notice Event emitted when interestRateModel is changed
176c241,244
<     event NewAdmin(address oldAdmin, address newAdmin);
---
>     event NewMarketInterestRateModel(
>         InterestRateModel oldInterestRateModel,
>         InterestRateModel newInterestRateModel
>     );
179c247
<      * @notice Event emitted when comptroller is changed
---
>      * @notice Event emitted when the reserve factor is changed
181c249,252
<     event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);
---
>     event NewReserveFactor(
>         uint256 oldReserveFactorMantissa,
>         uint256 newReserveFactorMantissa
>     );
184c255
<      * @notice Event emitted when interestRateModel is changed
---
>      * @notice Event emitted when the reserves are added
186c257,261
<     event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);
---
>     event ReservesAdded(
>         address benefactor,
>         uint256 addAmount,
>         uint256 newTotalReserves
>     );
189c264
<      * @notice Event emitted when the reserve factor is changed
---
>      * @notice Event emitted when the reserves are reduced
191c266,270
<     event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);
---
>     event ReservesReduced(
>         address admin,
>         uint256 reduceAmount,
>         uint256 newTotalReserves
>     );
194c273
<      * @notice Event emitted when the reserves are added
---
>      * @notice Event emitted when the admin fee is changed
196c275
<     event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);
---
>     event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);
199c278
<      * @notice Event emitted when the reserves are reduced
---
>      * @notice Event emitted when the Fuse fee is changed
201c280
<     event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);
---
>     event NewFuseFee(uint256 oldFuseFeeMantissa, uint256 newFuseFeeMantissa);
206c285
<     event Transfer(address indexed from, address indexed to, uint amount);
---
>     event Transfer(address indexed from, address indexed to, uint256 amount);
211c290,294
<     event Approval(address indexed owner, address indexed spender, uint amount);
---
>     event Approval(
>         address indexed owner,
>         address indexed spender,
>         uint256 amount
>     );
216,217c299
<     event Failure(uint error, uint info, uint detail);
< 
---
>     event Failure(uint256 error, uint256 info, uint256 detail);
221,237c303,338
<     function transfer(address dst, uint amount) external returns (bool);
<     function transferFrom(address src, address dst, uint amount) external returns (bool);
<     function approve(address spender, uint amount) external returns (bool);
<     function allowance(address owner, address spender) external view returns (uint);
<     function balanceOf(address owner) external view returns (uint);
<     function balanceOfUnderlying(address owner) external returns (uint);
<     function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);
<     function borrowRatePerBlock() external view returns (uint);
<     function supplyRatePerBlock() external view returns (uint);
<     function totalBorrowsCurrent() external returns (uint);
<     function borrowBalanceCurrent(address account) external returns (uint);
<     function borrowBalanceStored(address account) public view returns (uint);
<     function exchangeRateCurrent() public returns (uint);
<     function exchangeRateStored() public view returns (uint);
<     function getCash() external view returns (uint);
<     function accrueInterest() public returns (uint);
<     function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);
---
>     function transfer(address dst, uint256 amount) external returns (bool);
> 
>     function transferFrom(
>         address src,
>         address dst,
>         uint256 amount
>     ) external returns (bool);
> 
>     function approve(address spender, uint256 amount) external returns (bool);
> 
>     function allowance(address owner, address spender)
>         external
>         view
>         returns (uint256);
> 
>     function balanceOf(address owner) external view returns (uint256);
> 
>     function balanceOfUnderlying(address owner) external returns (uint256);
> 
>     function getAccountSnapshot(address account)
>         external
>         view
>         returns (
>             uint256,
>             uint256,
>             uint256,
>             uint256
>         );
> 
>     function borrowRatePerBlock() external view returns (uint256);
> 
>     function supplyRatePerBlock() external view returns (uint256);
> 
>     function totalBorrowsCurrent() external returns (uint256);
> 
>     function borrowBalanceCurrent(address account) external returns (uint256);
238a340,354
>     function borrowBalanceStored(address account) public view returns (uint256);
> 
>     function exchangeRateCurrent() public returns (uint256);
> 
>     function exchangeRateStored() public view returns (uint256);
> 
>     function getCash() external view returns (uint256);
> 
>     function accrueInterest() public returns (uint256);
> 
>     function seize(
>         address liquidator,
>         address borrower,
>         uint256 seizeTokens
>     ) external returns (uint256);
242,247c358,366
<     function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);
<     function _acceptAdmin() external returns (uint);
<     function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);
<     function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);
<     function _reduceReserves(uint reduceAmount) external returns (uint);
<     function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);
---
>     function _setReserveFactor(uint256 newReserveFactorMantissa)
>         external
>         returns (uint256);
> 
>     function _reduceReserves(uint256 reduceAmount) external returns (uint256);
> 
>     function _setInterestRateModel(InterestRateModel newInterestRateModel)
>         public
>         returns (uint256);
258d376
< 
261,268c379
<     function mint(uint mintAmount) external returns (uint);
<     function redeem(uint redeemTokens) external returns (uint);
<     function redeemUnderlying(uint redeemAmount) external returns (uint);
<     function borrow(uint borrowAmount) external returns (uint);
<     function repayBorrow(uint repayAmount) external returns (uint);
<     function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);
<     function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);
<     function sweepToken(EIP20NonStandardInterface token) external;
---
>     function mint(uint256 mintAmount) external returns (uint256);
269a381
>     function redeem(uint256 redeemTokens) external returns (uint256);
271c383,387
<     /*** Admin Functions ***/
---
>     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
> 
>     function borrow(uint256 borrowAmount) external returns (uint256);
> 
>     function repayBorrow(uint256 repayAmount) external returns (uint256);
273c389,404
<     function _addReserves(uint addAmount) external returns (uint);
---
>     function repayBorrowBehalf(address borrower, uint256 repayAmount)
>         external
>         returns (uint256);
> 
>     function liquidateBorrow(
>         address borrower,
>         uint256 repayAmount,
>         CTokenInterface cTokenCollateral
>     ) external returns (uint256);
> }
> 
> contract CEtherInterface is CErc20Storage {
>     /**
>      * @notice Indicator that this is a CEther contract (for inspection)
>      */
>     bool public constant isCEther = true;
283c414
< contract CDelegatorInterface is CDelegationStorage {
---
> contract CDelegateInterface is CDelegationStorage {
287c418,421
<     event NewImplementation(address oldImplementation, address newImplementation);
---
>     event NewImplementation(
>         address oldImplementation,
>         address newImplementation
>     );
295,296c429,433
<     function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;
< }
---
>     function _setImplementationSafe(
>         address implementation_,
>         bool allowResign,
>         bytes calldata becomeImplementationData
>     ) external;
298d434
< contract CDelegateInterface is CDelegationStorage {
304c440
<     function _becomeImplementation(bytes memory data) public;
---
>     function _becomeImplementation(bytes calldata data) external;
307c443,444
<      * @notice Called by the delegator on a delegate to forfeit its responsibility
---
>      * @notice Function called before all delegator functions
>      * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary
309c446
<     function _resignImplementation() public;
---
>     function _prepare() external payable;
diff -x .git -r ../compound-protocol/contracts/CToken.sol src/core/CToken.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
7a8
> import "./EIP20NonStandardInterface.sol";
16a18,31
>      * @notice Returns a boolean indicating if the sender has admin rights
>      */
>     function hasAdminRights() internal view returns (bool) {
>         ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(
>             address(comptroller)
>         );
>         return
>             (msg.sender == comptrollerStorage.admin() &&
>                 comptrollerStorage.adminHasRights()) ||
>             (msg.sender == address(fuseAdmin) &&
>                 comptrollerStorage.fuseAdminHasRights());
>     }
> 
>     /**
25,32c40,57
<     function initialize(ComptrollerInterface comptroller_,
<                         InterestRateModel interestRateModel_,
<                         uint initialExchangeRateMantissa_,
<                         string memory name_,
<                         string memory symbol_,
<                         uint8 decimals_) public {
<         require(msg.sender == admin, "only admin may initialize the market");
<         require(accrualBlockNumber == 0 && borrowIndex == 0, "market may only be initialized once");
---
>     function initialize(
>         ComptrollerInterface comptroller_,
>         InterestRateModel interestRateModel_,
>         uint256 initialExchangeRateMantissa_,
>         string memory name_,
>         string memory symbol_,
>         uint8 decimals_,
>         uint256 reserveFactorMantissa_,
>         uint256 adminFeeMantissa_
>     ) public {
>         require(
>             msg.sender == address(fuseAdmin),
>             "only Fuse admin may initialize the market"
>         );
>         require(
>             accrualBlockNumber == 0 && borrowIndex == 0,
>             "market may only be initialized once"
>         );
36c61,64
<         require(initialExchangeRateMantissa > 0, "initial exchange rate must be greater than zero.");
---
>         require(
>             initialExchangeRateMantissa > 0,
>             "initial exchange rate must be greater than zero."
>         );
39,40c67,68
<         uint err = _setComptroller(comptroller_);
<         require(err == uint(Error.NO_ERROR), "setting comptroller failed");
---
>         uint256 err = _setComptroller(comptroller_);
>         require(err == uint256(Error.NO_ERROR), "setting comptroller failed");
48c76,79
<         require(err == uint(Error.NO_ERROR), "setting interest rate model failed");
---
>         require(
>             err == uint256(Error.NO_ERROR),
>             "setting interest rate model failed"
>         );
53a85,95
>         // Set reserve factor
>         err = _setReserveFactorFresh(reserveFactorMantissa_);
>         require(
>             err == uint256(Error.NO_ERROR),
>             "setting reserve factor failed"
>         );
> 
>         // Set admin fee
>         err = _setAdminFeeFresh(adminFeeMantissa_);
>         require(err == uint256(Error.NO_ERROR), "setting admin fee failed");
> 
58a101,107
>      * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)
>      */
>     function getPendingFuseFeeFromAdmin() internal view returns (uint256) {
>         return fuseAdmin.interestFeeRate();
>     }
> 
>     /**
67c116,121
<     function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
---
>     function transferTokens(
>         address spender,
>         address src,
>         address dst,
>         uint256 tokens
>     ) internal returns (uint256) {
69c123,128
<         uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
---
>         uint256 allowed = comptroller.transferAllowed(
>             address(this),
>             src,
>             dst,
>             tokens
>         );
71c130,135
<             return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
---
>             return
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.TRANSFER_COMPTROLLER_REJECTION,
>                     allowed
>                 );
80c144
<         uint startingAllowance = 0;
---
>         uint256 startingAllowance = 0;
82c146
<             startingAllowance = uint(-1);
---
>             startingAllowance = uint256(-1);
89,91c153,155
<         uint allowanceNew;
<         uint srcTokensNew;
<         uint dstTokensNew;
---
>         uint256 allowanceNew;
>         uint256 srcTokensNew;
>         uint256 dstTokensNew;
116c180
<         if (startingAllowance != uint(-1)) {
---
>         if (startingAllowance != uint256(-1)) {
122a187
>         /* We call the defense hook */
126c191
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
135,136c200,207
<     function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
<         return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
---
>     function transfer(address dst, uint256 amount)
>         external
>         nonReentrant(false)
>         returns (bool)
>     {
>         return
>             transferTokens(msg.sender, msg.sender, dst, amount) ==
>             uint256(Error.NO_ERROR);
146,147c217,224
<     function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
<         return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
---
>     function transferFrom(
>         address src,
>         address dst,
>         uint256 amount
>     ) external nonReentrant(false) returns (bool) {
>         return
>             transferTokens(msg.sender, src, dst, amount) ==
>             uint256(Error.NO_ERROR);
171c248,252
<     function allowance(address owner, address spender) external view returns (uint256) {
---
>     function allowance(address owner, address spender)
>         external
>         view
>         returns (uint256)
>     {
190c271
<     function balanceOfUnderlying(address owner) external returns (uint) {
---
>     function balanceOfUnderlying(address owner) external returns (uint256) {
192c273,276
<         (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
---
>         (MathError mErr, uint256 balance) = mulScalarTruncate(
>             exchangeRate,
>             accountTokens[owner]
>         );
203,206c287,299
<     function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
<         uint cTokenBalance = accountTokens[account];
<         uint borrowBalance;
<         uint exchangeRateMantissa;
---
>     function getAccountSnapshot(address account)
>         external
>         view
>         returns (
>             uint256,
>             uint256,
>             uint256,
>             uint256
>         )
>     {
>         uint256 cTokenBalance = accountTokens[account];
>         uint256 borrowBalance;
>         uint256 exchangeRateMantissa;
212c305
<             return (uint(Error.MATH_ERROR), 0, 0, 0);
---
>             return (uint256(Error.MATH_ERROR), 0, 0, 0);
217c310
<             return (uint(Error.MATH_ERROR), 0, 0, 0);
---
>             return (uint256(Error.MATH_ERROR), 0, 0, 0);
220c313,318
<         return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
---
>         return (
>             uint256(Error.NO_ERROR),
>             cTokenBalance,
>             borrowBalance,
>             exchangeRateMantissa
>         );
227c325
<     function getBlockNumber() internal view returns (uint) {
---
>     function getBlockNumber() internal view returns (uint256) {
235,236c333,339
<     function borrowRatePerBlock() external view returns (uint) {
<         return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
---
>     function borrowRatePerBlock() external view returns (uint256) {
>         return
>             interestRateModel.getBorrowRate(
>                 getCashPrior(),
>                 totalBorrows,
>                 add_(totalReserves, add_(totalAdminFees, totalFuseFees))
>             );
243,244c346,353
<     function supplyRatePerBlock() external view returns (uint) {
<         return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
---
>     function supplyRatePerBlock() external view returns (uint256) {
>         return
>             interestRateModel.getSupplyRate(
>                 getCashPrior(),
>                 totalBorrows,
>                 add_(totalReserves, add_(totalAdminFees, totalFuseFees)),
>                 reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa
>             );
251,252c360,368
<     function totalBorrowsCurrent() external nonReentrant returns (uint) {
<         require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
---
>     function totalBorrowsCurrent()
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         require(
>             accrueInterest() == uint256(Error.NO_ERROR),
>             "accrue interest failed"
>         );
261,262c377,385
<     function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
<         require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
---
>     function borrowBalanceCurrent(address account)
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         require(
>             accrueInterest() == uint256(Error.NO_ERROR),
>             "accrue interest failed"
>         );
271,273c394,403
<     function borrowBalanceStored(address account) public view returns (uint) {
<         (MathError err, uint result) = borrowBalanceStoredInternal(account);
<         require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
---
>     function borrowBalanceStored(address account)
>         public
>         view
>         returns (uint256)
>     {
>         (MathError err, uint256 result) = borrowBalanceStoredInternal(account);
>         require(
>             err == MathError.NO_ERROR,
>             "borrowBalanceStored: borrowBalanceStoredInternal failed"
>         );
282c412,416
<     function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
---
>     function borrowBalanceStoredInternal(address account)
>         internal
>         view
>         returns (MathError, uint256)
>     {
285,286c419,420
<         uint principalTimesIndex;
<         uint result;
---
>         uint256 principalTimesIndex;
>         uint256 result;
301c435,438
<         (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
---
>         (mathErr, principalTimesIndex) = mulUInt(
>             borrowSnapshot.principal,
>             borrowIndex
>         );
306c443,446
<         (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
---
>         (mathErr, result) = divUInt(
>             principalTimesIndex,
>             borrowSnapshot.interestIndex
>         );
318,319c458,466
<     function exchangeRateCurrent() public nonReentrant returns (uint) {
<         require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
---
>     function exchangeRateCurrent()
>         public
>         nonReentrant(false)
>         returns (uint256)
>     {
>         require(
>             accrueInterest() == uint256(Error.NO_ERROR),
>             "accrue interest failed"
>         );
328,330c475,480
<     function exchangeRateStored() public view returns (uint) {
<         (MathError err, uint result) = exchangeRateStoredInternal();
<         require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
---
>     function exchangeRateStored() public view returns (uint256) {
>         (MathError err, uint256 result) = exchangeRateStoredInternal();
>         require(
>             err == MathError.NO_ERROR,
>             "exchangeRateStored: exchangeRateStoredInternal failed"
>         );
339,340c489,494
<     function exchangeRateStoredInternal() internal view returns (MathError, uint) {
<         uint _totalSupply = totalSupply;
---
>     function exchangeRateStoredInternal()
>         internal
>         view
>         returns (MathError, uint256)
>     {
>         uint256 _totalSupply = totalSupply;
350c504
<              *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
---
>              *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply
352,353c506,507
<             uint totalCash = getCashPrior();
<             uint cashPlusBorrowsMinusReserves;
---
>             uint256 totalCash = getCashPrior();
>             uint256 cashPlusBorrowsMinusReserves;
357c511,515
<             (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
---
>             (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(
>                 totalCash,
>                 totalBorrows,
>                 add_(totalReserves, add_(totalAdminFees, totalFuseFees))
>             );
362c520,523
<             (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
---
>             (mathErr, exchangeRate) = getExp(
>                 cashPlusBorrowsMinusReserves,
>                 _totalSupply
>             );
375c536
<     function getCash() external view returns (uint) {
---
>     function getCash() external view returns (uint256) {
384c545
<     function accrueInterest() public returns (uint) {
---
>     function accrueInterest() public returns (uint256) {
386,387c547
<         uint currentBlockNumber = getBlockNumber();
<         uint accrualBlockNumberPrior = accrualBlockNumber;
---
>         uint256 currentBlockNumber = getBlockNumber();
390,391c550,551
<         if (accrualBlockNumberPrior == currentBlockNumber) {
<             return uint(Error.NO_ERROR);
---
>         if (accrualBlockNumber == currentBlockNumber) {
>             return uint256(Error.NO_ERROR);
395,398c555
<         uint cashPrior = getCashPrior();
<         uint borrowsPrior = totalBorrows;
<         uint reservesPrior = totalReserves;
<         uint borrowIndexPrior = borrowIndex;
---
>         uint256 cashPrior = getCashPrior();
401,402c558,566
<         uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);
<         require(borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
---
>         uint256 borrowRateMantissa = interestRateModel.getBorrowRate(
>             cashPrior,
>             totalBorrows,
>             add_(totalReserves, add_(totalAdminFees, totalFuseFees))
>         );
>         require(
>             borrowRateMantissa <= borrowRateMaxMantissa,
>             "borrow rate is absurdly high"
>         );
405,406c569,585
<         (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
<         require(mathErr == MathError.NO_ERROR, "could not calculate block delta");
---
>         (MathError mathErr, uint256 blockDelta) = subUInt(
>             currentBlockNumber,
>             accrualBlockNumber
>         );
>         require(
>             mathErr == MathError.NO_ERROR,
>             "could not calculate block delta"
>         );
> 
>         return
>             finishInterestAccrual(
>                 currentBlockNumber,
>                 cashPrior,
>                 borrowRateMantissa,
>                 blockDelta
>             );
>     }
407a587,595
>     /**
>      * @dev Split off from `accrueInterest` to avoid "stack too deep" error".
>      */
>     function finishInterestAccrual(
>         uint256 currentBlockNumber,
>         uint256 cashPrior,
>         uint256 borrowRateMantissa,
>         uint256 blockDelta
>     ) private returns (uint256) {
413a602,603
>          *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees
>          *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees
417,446c607,635
<         Exp memory simpleInterestFactor;
<         uint interestAccumulated;
<         uint totalBorrowsNew;
<         uint totalReservesNew;
<         uint borrowIndexNew;
< 
<         (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);
<         if (mathErr != MathError.NO_ERROR) {
<             return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));
<         }
< 
<         (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
<         if (mathErr != MathError.NO_ERROR) {
<             return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));
<         }
< 
<         (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
<         if (mathErr != MathError.NO_ERROR) {
<             return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));
<         }
< 
<         (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);
<         if (mathErr != MathError.NO_ERROR) {
<             return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));
<         }
< 
<         (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
<         if (mathErr != MathError.NO_ERROR) {
<             return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));
<         }
---
>         Exp memory simpleInterestFactor = mul_(
>             Exp({mantissa: borrowRateMantissa}),
>             blockDelta
>         );
>         uint256 interestAccumulated = mul_ScalarTruncate(
>             simpleInterestFactor,
>             totalBorrows
>         );
>         uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);
>         uint256 totalReservesNew = mul_ScalarTruncateAddUInt(
>             Exp({mantissa: reserveFactorMantissa}),
>             interestAccumulated,
>             totalReserves
>         );
>         uint256 totalFuseFeesNew = mul_ScalarTruncateAddUInt(
>             Exp({mantissa: fuseFeeMantissa}),
>             interestAccumulated,
>             totalFuseFees
>         );
>         uint256 totalAdminFeesNew = mul_ScalarTruncateAddUInt(
>             Exp({mantissa: adminFeeMantissa}),
>             interestAccumulated,
>             totalAdminFees
>         );
>         uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(
>             simpleInterestFactor,
>             borrowIndex,
>             borrowIndex
>         );
456a646,647
>         totalFuseFees = totalFuseFeesNew;
>         totalAdminFees = totalAdminFeesNew;
459c650,663
<         emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);
---
>         emit AccrueInterest(
>             cashPrior,
>             interestAccumulated,
>             borrowIndexNew,
>             totalBorrowsNew
>         );
> 
>         // Attempt to add interest checkpoint
>         address(interestRateModel).call(
>             abi.encodeWithSignature(
>                 "checkpointInterest(uint256)",
>                 borrowRateMantissa
>             )
>         );
461c665
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
470,472c674,680
<     function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function mintInternal(uint256 mintAmount)
>         internal
>         nonReentrant(false)
>         returns (uint256, uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
474c682,685
<             return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);
---
>             return (
>                 fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED),
>                 0
>             );
483,487c694,698
<         uint exchangeRateMantissa;
<         uint mintTokens;
<         uint totalSupplyNew;
<         uint accountTokensNew;
<         uint actualMintAmount;
---
>         uint256 exchangeRateMantissa;
>         uint256 mintTokens;
>         uint256 totalSupplyNew;
>         uint256 accountTokensNew;
>         uint256 actualMintAmount;
497c708,711
<     function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {
---
>     function mintFresh(address minter, uint256 mintAmount)
>         internal
>         returns (uint256, uint256)
>     {
499c713,717
<         uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
---
>         uint256 allowed = comptroller.mintAllowed(
>             address(this),
>             minter,
>             mintAmount
>         );
501c719,726
<             return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);
---
>             return (
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.MINT_COMPTROLLER_REJECTION,
>                     allowed
>                 ),
>                 0
>             );
506c731,734
<             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);
---
>             return (
>                 fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK),
>                 0
>             );
511c739,742
<         (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
---
>         (
>             vars.mathErr,
>             vars.exchangeRateMantissa
>         ) = exchangeRateStoredInternal();
513c744,751
<             return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);
---
>             return (
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED,
>                     uint256(vars.mathErr)
>                 ),
>                 0
>             );
515a754,760
>         // Check max supply
>         // unused function
>         /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);
>         if (allowed != 0) {
>             return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);
>         } */
> 
535,536c780,787
<         (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
<         require(vars.mathErr == MathError.NO_ERROR, "MINT_EXCHANGE_CALCULATION_FAILED");
---
>         (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(
>             vars.actualMintAmount,
>             Exp({mantissa: vars.exchangeRateMantissa})
>         );
>         require(
>             vars.mathErr == MathError.NO_ERROR,
>             "MINT_EXCHANGE_CALCULATION_FAILED"
>         );
543,544c794
<         (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
<         require(vars.mathErr == MathError.NO_ERROR, "MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED");
---
>         vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);
546,547c796
<         (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
<         require(vars.mathErr == MathError.NO_ERROR, "MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED");
---
>         vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);
558,559c807,812
<         // unused function
<         // comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);
---
>         comptroller.mintVerify(
>             address(this),
>             minter,
>             vars.actualMintAmount,
>             vars.mintTokens
>         );
561c814
<         return (uint(Error.NO_ERROR), vars.actualMintAmount);
---
>         return (uint256(Error.NO_ERROR), vars.actualMintAmount);
570,572c823,829
<     function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function redeemInternal(uint256 redeemTokens)
>         internal
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
574c831,832
<             return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
---
>             return
>                 fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
586,588c844,850
<     function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function redeemUnderlyingInternal(uint256 redeemAmount)
>         internal
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
590c852,853
<             return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
---
>             return
>                 fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
599,603c862,866
<         uint exchangeRateMantissa;
<         uint redeemTokens;
<         uint redeemAmount;
<         uint totalSupplyNew;
<         uint accountTokensNew;
---
>         uint256 exchangeRateMantissa;
>         uint256 redeemTokens;
>         uint256 redeemAmount;
>         uint256 totalSupplyNew;
>         uint256 accountTokensNew;
614,615c877,885
<     function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
<         require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");
---
>     function redeemFresh(
>         address payable redeemer,
>         uint256 redeemTokensIn,
>         uint256 redeemAmountIn
>     ) internal returns (uint256) {
>         require(
>             redeemTokensIn == 0 || redeemAmountIn == 0,
>             "one of redeemTokensIn or redeemAmountIn must be zero"
>         );
620c890,893
<         (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
---
>         (
>             vars.mathErr,
>             vars.exchangeRateMantissa
>         ) = exchangeRateStoredInternal();
622c895,900
<             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED,
>                     uint256(vars.mathErr)
>                 );
634c912,915
<             (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
---
>             (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(
>                 Exp({mantissa: vars.exchangeRateMantissa}),
>                 redeemTokensIn
>             );
636c917,922
<                 return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
---
>                 return
>                     failOpaque(
>                         Error.MATH_ERROR,
>                         FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,
>                         uint256(vars.mathErr)
>                     );
645c931,934
<             (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
---
>             (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(
>                 redeemAmountIn,
>                 Exp({mantissa: vars.exchangeRateMantissa})
>             );
647c936,941
<                 return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
---
>                 return
>                     failOpaque(
>                         Error.MATH_ERROR,
>                         FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,
>                         uint256(vars.mathErr)
>                     );
654c948,952
<         uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
---
>         uint256 allowed = comptroller.redeemAllowed(
>             address(this),
>             redeemer,
>             vars.redeemTokens
>         );
656c954,959
<             return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
---
>             return
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.REDEEM_COMPTROLLER_REJECTION,
>                     allowed
>                 );
661c964,968
<             return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.REDEEM_FRESHNESS_CHECK
>                 );
669c976,979
<         (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
---
>         (vars.mathErr, vars.totalSupplyNew) = subUInt(
>             totalSupply,
>             vars.redeemTokens
>         );
671c981,986
<             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,
>                     uint256(vars.mathErr)
>                 );
674c989,992
<         (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
---
>         (vars.mathErr, vars.accountTokensNew) = subUInt(
>             accountTokens[redeemer],
>             vars.redeemTokens
>         );
676c994,999
<             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,
>                     uint256(vars.mathErr)
>                 );
681c1004,1008
<             return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
---
>             return
>                 fail(
>                     Error.TOKEN_INSUFFICIENT_CASH,
>                     FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE
>                 );
705c1032,1037
<         comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);
---
>         comptroller.redeemVerify(
>             address(this),
>             redeemer,
>             vars.redeemAmount,
>             vars.redeemTokens
>         );
707c1039
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
711,717c1043,1053
<       * @notice Sender borrows assets from the protocol to their own address
<       * @param borrowAmount The amount of the underlying asset to borrow
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>      * @notice Sender borrows assets from the protocol to their own address
>      * @param borrowAmount The amount of the underlying asset to borrow
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function borrowInternal(uint256 borrowAmount)
>         internal
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
719c1055,1056
<             return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
---
>             return
>                 fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
727,729c1064,1066
<         uint accountBorrows;
<         uint accountBorrowsNew;
<         uint totalBorrowsNew;
---
>         uint256 accountBorrows;
>         uint256 accountBorrowsNew;
>         uint256 totalBorrowsNew;
733,737c1070,1077
<       * @notice Users borrow assets from the protocol to their own address
<       * @param borrowAmount The amount of the underlying asset to borrow
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
---
>      * @notice Users borrow assets from the protocol to their own address
>      * @param borrowAmount The amount of the underlying asset to borrow
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function borrowFresh(address payable borrower, uint256 borrowAmount)
>         internal
>         returns (uint256)
>     {
739c1079,1083
<         uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
---
>         uint256 allowed = comptroller.borrowAllowed(
>             address(this),
>             borrower,
>             borrowAmount
>         );
741c1085,1090
<             return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
---
>             return
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.BORROW_COMPTROLLER_REJECTION,
>                     allowed
>                 );
746c1095,1099
<             return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.BORROW_FRESHNESS_CHECK
>                 );
750,751c1103,1110
<         if (getCashPrior() < borrowAmount) {
<             return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
---
>         uint256 cashPrior = getCashPrior();
> 
>         if (cashPrior < borrowAmount) {
>             return
>                 fail(
>                     Error.TOKEN_INSUFFICIENT_CASH,
>                     FailureInfo.BORROW_CASH_NOT_AVAILABLE
>                 );
761c1120,1122
<         (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
---
>         (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(
>             borrower
>         );
763c1124,1129
<             return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,
>                     uint256(vars.mathErr)
>                 );
766c1132,1135
<         (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
---
>         (vars.mathErr, vars.accountBorrowsNew) = addUInt(
>             vars.accountBorrows,
>             borrowAmount
>         );
768c1137,1157
<             return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo
>                         .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,
>                     uint256(vars.mathErr)
>                 );
>         }
> 
>         // Check min borrow for this user for this asset
>         allowed = comptroller.borrowWithinLimits(
>             address(this),
>             vars.accountBorrowsNew
>         );
>         if (allowed != 0) {
>             return
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.BORROW_COMPTROLLER_REJECTION,
>                     allowed
>                 );
771c1160,1163
<         (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
---
>         (vars.mathErr, vars.totalBorrowsNew) = addUInt(
>             totalBorrows,
>             borrowAmount
>         );
773c1165,1170
<             return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,
>                     uint256(vars.mathErr)
>                 );
794c1191,1196
<         emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
---
>         emit Borrow(
>             borrower,
>             borrowAmount,
>             vars.accountBorrowsNew,
>             vars.totalBorrowsNew
>         );
800c1202
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
808,810c1210,1216
<     function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function repayBorrowInternal(uint256 repayAmount)
>         internal
>         nonReentrant(false)
>         returns (uint256, uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
812c1218,1224
<             return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);
---
>             return (
>                 fail(
>                     Error(error),
>                     FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED
>                 ),
>                 0
>             );
824,826c1236,1242
<     function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)
>         internal
>         nonReentrant(false)
>         returns (uint256, uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
828c1244,1250
<             return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);
---
>             return (
>                 fail(
>                     Error(error),
>                     FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED
>                 ),
>                 0
>             );
837,842c1259,1264
<         uint repayAmount;
<         uint borrowerIndex;
<         uint accountBorrows;
<         uint accountBorrowsNew;
<         uint totalBorrowsNew;
<         uint actualRepayAmount;
---
>         uint256 repayAmount;
>         uint256 borrowerIndex;
>         uint256 accountBorrows;
>         uint256 accountBorrowsNew;
>         uint256 totalBorrowsNew;
>         uint256 actualRepayAmount;
852c1274,1278
<     function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {
---
>     function repayBorrowFresh(
>         address payer,
>         address borrower,
>         uint256 repayAmount
>     ) internal returns (uint256, uint256) {
854c1280,1285
<         uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
---
>         uint256 allowed = comptroller.repayBorrowAllowed(
>             address(this),
>             payer,
>             borrower,
>             repayAmount
>         );
856c1287,1294
<             return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);
---
>             return (
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION,
>                     allowed
>                 ),
>                 0
>             );
861c1299,1305
<             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);
---
>             return (
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.REPAY_BORROW_FRESHNESS_CHECK
>                 ),
>                 0
>             );
870c1314,1316
<         (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
---
>         (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(
>             borrower
>         );
872c1318,1326
<             return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);
---
>             return (
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo
>                         .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,
>                     uint256(vars.mathErr)
>                 ),
>                 0
>             );
876c1330
<         if (repayAmount == uint(-1)) {
---
>         if (repayAmount == uint256(-1)) {
900,904c1354,1370
<         (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);
<         require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED");
< 
<         (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);
<         require(vars.mathErr == MathError.NO_ERROR, "REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED");
---
>         (vars.mathErr, vars.accountBorrowsNew) = subUInt(
>             vars.accountBorrows,
>             vars.actualRepayAmount
>         );
>         require(
>             vars.mathErr == MathError.NO_ERROR,
>             "REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED"
>         );
> 
>         (vars.mathErr, vars.totalBorrowsNew) = subUInt(
>             totalBorrows,
>             vars.actualRepayAmount
>         );
>         require(
>             vars.mathErr == MathError.NO_ERROR,
>             "REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED"
>         );
912c1378,1384
<         emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
---
>         emit RepayBorrow(
>             payer,
>             borrower,
>             vars.actualRepayAmount,
>             vars.accountBorrowsNew,
>             vars.totalBorrowsNew
>         );
918c1390
<         return (uint(Error.NO_ERROR), vars.actualRepayAmount);
---
>         return (uint256(Error.NO_ERROR), vars.actualRepayAmount);
929,931c1401,1407
<     function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function liquidateBorrowInternal(
>         address borrower,
>         uint256 repayAmount,
>         CTokenInterface cTokenCollateral
>     ) internal nonReentrant(false) returns (uint256, uint256) {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
933c1409,1415
<             return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);
---
>             return (
>                 fail(
>                     Error(error),
>                     FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED
>                 ),
>                 0
>             );
937c1419
<         if (error != uint(Error.NO_ERROR)) {
---
>         if (error != uint256(Error.NO_ERROR)) {
939c1421,1427
<             return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);
---
>             return (
>                 fail(
>                     Error(error),
>                     FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED
>                 ),
>                 0
>             );
943c1431,1437
<         return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
---
>         return
>             liquidateBorrowFresh(
>                 msg.sender,
>                 borrower,
>                 repayAmount,
>                 cTokenCollateral
>             );
955c1449,1454
<     function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {
---
>     function liquidateBorrowFresh(
>         address liquidator,
>         address borrower,
>         uint256 repayAmount,
>         CTokenInterface cTokenCollateral
>     ) internal returns (uint256, uint256) {
957c1456,1462
<         uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
---
>         uint256 allowed = comptroller.liquidateBorrowAllowed(
>             address(this),
>             address(cTokenCollateral),
>             liquidator,
>             borrower,
>             repayAmount
>         );
959c1464,1471
<             return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);
---
>             return (
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION,
>                     allowed
>                 ),
>                 0
>             );
964c1476,1482
<             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);
---
>             return (
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.LIQUIDATE_FRESHNESS_CHECK
>                 ),
>                 0
>             );
969c1487,1493
<             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);
---
>             return (
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK
>                 ),
>                 0
>             );
974c1498,1504
<             return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);
---
>             return (
>                 fail(
>                     Error.INVALID_ACCOUNT_PAIR,
>                     FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER
>                 ),
>                 0
>             );
979c1509,1515
<             return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);
---
>             return (
>                 fail(
>                     Error.INVALID_CLOSE_AMOUNT_REQUESTED,
>                     FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO
>                 ),
>                 0
>             );
983,984c1519,1526
<         if (repayAmount == uint(-1)) {
<             return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);
---
>         if (repayAmount == uint256(-1)) {
>             return (
>                 fail(
>                     Error.INVALID_CLOSE_AMOUNT_REQUESTED,
>                     FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX
>                 ),
>                 0
>             );
987d1528
< 
989,991c1530,1541
<         (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);
<         if (repayBorrowError != uint(Error.NO_ERROR)) {
<             return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);
---
>         (
>             uint256 repayBorrowError,
>             uint256 actualRepayAmount
>         ) = repayBorrowFresh(liquidator, borrower, repayAmount);
>         if (repayBorrowError != uint256(Error.NO_ERROR)) {
>             return (
>                 fail(
>                     Error(repayBorrowError),
>                     FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED
>                 ),
>                 0
>             );
999,1000c1549,1558
<         (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);
<         require(amountSeizeError == uint(Error.NO_ERROR), "LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED");
---
>         (uint256 amountSeizeError, uint256 seizeTokens) = comptroller
>             .liquidateCalculateSeizeTokens(
>                 address(this),
>                 address(cTokenCollateral),
>                 actualRepayAmount
>             );
>         require(
>             amountSeizeError == uint256(Error.NO_ERROR),
>             "LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED"
>         );
1003c1561,1564
<         require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, "LIQUIDATE_SEIZE_TOO_MUCH");
---
>         require(
>             cTokenCollateral.balanceOf(borrower) >= seizeTokens,
>             "LIQUIDATE_SEIZE_TOO_MUCH"
>         );
1006c1567
<         uint seizeError;
---
>         uint256 seizeError;
1008c1569,1574
<             seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);
---
>             seizeError = seizeInternal(
>                 address(this),
>                 liquidator,
>                 borrower,
>                 seizeTokens
>             );
1010c1576,1580
<             seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
---
>             seizeError = cTokenCollateral.seize(
>                 liquidator,
>                 borrower,
>                 seizeTokens
>             );
1014c1584
<         require(seizeError == uint(Error.NO_ERROR), "token seizure failed");
---
>         require(seizeError == uint256(Error.NO_ERROR), "token seizure failed");
1017c1587,1593
<         emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);
---
>         emit LiquidateBorrow(
>             liquidator,
>             borrower,
>             actualRepayAmount,
>             address(cTokenCollateral),
>             seizeTokens
>         );
1023c1599
<         return (uint(Error.NO_ERROR), actualRepayAmount);
---
>         return (uint256(Error.NO_ERROR), actualRepayAmount);
1035c1611,1615
<     function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
---
>     function seize(
>         address liquidator,
>         address borrower,
>         uint256 seizeTokens
>     ) external nonReentrant(true) returns (uint256) {
1041,1048c1621,1628
<         uint borrowerTokensNew;
<         uint liquidatorTokensNew;
<         uint liquidatorSeizeTokens;
<         uint protocolSeizeTokens;
<         uint protocolSeizeAmount;
<         uint exchangeRateMantissa;
<         uint totalReservesNew;
<         uint totalSupplyNew;
---
>         uint256 borrowerTokensNew;
>         uint256 liquidatorTokensNew;
>         uint256 liquidatorSeizeTokens;
>         uint256 protocolSeizeTokens;
>         uint256 protocolSeizeAmount;
>         uint256 exchangeRateMantissa;
>         uint256 totalReservesNew;
>         uint256 totalSupplyNew;
1061c1641,1646
<     function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
---
>     function seizeInternal(
>         address seizerToken,
>         address liquidator,
>         address borrower,
>         uint256 seizeTokens
>     ) internal returns (uint256) {
1063c1648,1654
<         uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);
---
>         uint256 allowed = comptroller.seizeAllowed(
>             address(this),
>             seizerToken,
>             liquidator,
>             borrower,
>             seizeTokens
>         );
1065c1656,1661
<             return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
---
>             return
>                 failOpaque(
>                     Error.COMPTROLLER_REJECTION,
>                     FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,
>                     allowed
>                 );
1070c1666,1670
<             return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
---
>             return
>                 fail(
>                     Error.INVALID_ACCOUNT_PAIR,
>                     FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER
>                 );
1080c1680,1683
<         (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
---
>         (vars.mathErr, vars.borrowerTokensNew) = subUInt(
>             accountTokens[borrower],
>             seizeTokens
>         );
1082,1088c1685,1705
<             return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(vars.mathErr));
<         }
< 
<         vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));
<         vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);
< 
<         (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,
>                     uint256(vars.mathErr)
>                 );
>         }
> 
>         vars.protocolSeizeTokens = mul_(
>             seizeTokens,
>             Exp({mantissa: protocolSeizeShareMantissa})
>         );
>         vars.liquidatorSeizeTokens = sub_(
>             seizeTokens,
>             vars.protocolSeizeTokens
>         );
> 
>         (
>             vars.mathErr,
>             vars.exchangeRateMantissa
>         ) = exchangeRateStoredInternal();
1091c1708,1711
<         vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);
---
>         vars.protocolSeizeAmount = mul_ScalarTruncate(
>             Exp({mantissa: vars.exchangeRateMantissa}),
>             vars.protocolSeizeTokens
>         );
1096c1716,1719
<         (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);
---
>         (vars.mathErr, vars.liquidatorTokensNew) = addUInt(
>             accountTokens[liquidator],
>             vars.liquidatorSeizeTokens
>         );
1098c1721,1726
<             return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(vars.mathErr));
---
>             return
>                 failOpaque(
>                     Error.MATH_ERROR,
>                     FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,
>                     uint256(vars.mathErr)
>                 );
1114c1742,1746
<         emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);
---
>         emit ReservesAdded(
>             address(this),
>             vars.protocolSeizeAmount,
>             vars.totalReservesNew
>         );
1120c1752
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
1123d1754
< 
1127,1139c1758,1768
<       * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
<       * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
<       * @param newPendingAdmin New pending admin.
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
<         // Check caller = admin
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
<         }
< 
<         // Save current value, if any, for inclusion in log
<         address oldPendingAdmin = pendingAdmin;
---
>      * @notice Sets a new comptroller for the market
>      * @dev Internal function to set a new comptroller
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setComptroller(ComptrollerInterface newComptroller)
>         internal
>         returns (uint256)
>     {
>         ComptrollerInterface oldComptroller = comptroller;
>         // Ensure invoke comptroller.isComptroller() returns true
>         require(newComptroller.isComptroller(), "marker method returned false");
1141,1142c1770,1771
<         // Store pendingAdmin with value newPendingAdmin
<         pendingAdmin = newPendingAdmin;
---
>         // Set market's comptroller to newComptroller
>         comptroller = newComptroller;
1144,1145c1773,1774
<         // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
<         emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);
---
>         // Emit NewComptroller(oldComptroller, newComptroller)
>         emit NewComptroller(oldComptroller, newComptroller);
1147c1776
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
1151,1158c1780,1796
<       * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
<       * @dev Admin function for pending admin to accept role and update admin
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _acceptAdmin() external returns (uint) {
<         // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
<         if (msg.sender != pendingAdmin || msg.sender == address(0)) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
---
>      * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh
>      * @dev Admin function to accrue interest and set a new admin fee
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setAdminFee(uint256 newAdminFeeMantissa)
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
>             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.
>             return
>                 fail(
>                     Error(error),
>                     FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED
>                 );
1160,1174c1798,1799
< 
<         // Save current values for inclusion in log
<         address oldAdmin = admin;
<         address oldPendingAdmin = pendingAdmin;
< 
<         // Store admin with value pendingAdmin
<         admin = pendingAdmin;
< 
<         // Clear the pending value
<         pendingAdmin = address(0);
< 
<         emit NewAdmin(oldAdmin, admin);
<         emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);
< 
<         return uint(Error.NO_ERROR);
---
>         // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.
>         return _setAdminFeeFresh(newAdminFeeMantissa);
1178,1186c1803,1847
<       * @notice Sets a new comptroller for the market
<       * @dev Admin function to set a new comptroller
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
<         // Check caller is admin
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
<         }
---
>      * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)
>      * @dev Admin function to set a new admin fee
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setAdminFeeFresh(uint256 newAdminFeeMantissa)
>         internal
>         returns (uint256)
>     {
>         // Verify market's block number equals current block number
>         if (accrualBlockNumber != getBlockNumber()) {
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.SET_ADMIN_FEE_FRESH_CHECK
>                 );
>         }
> 
>         // Sanitize newAdminFeeMantissa
>         if (newAdminFeeMantissa == uint256(-1))
>             newAdminFeeMantissa = adminFeeMantissa;
> 
>         // Get latest Fuse fee
>         uint256 newFuseFeeMantissa = getPendingFuseFeeFromAdmin();
> 
>         // Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa ≤ reserveFactorPlusFeesMaxMantissa
>         if (
>             add_(
>                 add_(reserveFactorMantissa, newAdminFeeMantissa),
>                 newFuseFeeMantissa
>             ) > reserveFactorPlusFeesMaxMantissa
>         ) {
>             return
>                 fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);
>         }
> 
>         // If setting admin fee
>         if (adminFeeMantissa != newAdminFeeMantissa) {
>             // Check caller is admin
>             if (!hasAdminRights()) {
>                 return
>                     fail(
>                         Error.UNAUTHORIZED,
>                         FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK
>                     );
>             }
1188,1190c1849,1851
<         ComptrollerInterface oldComptroller = comptroller;
<         // Ensure invoke comptroller.isComptroller() returns true
<         require(newComptroller.isComptroller(), "marker method returned false");
---
>             // Set admin fee
>             uint256 oldAdminFeeMantissa = adminFeeMantissa;
>             adminFeeMantissa = newAdminFeeMantissa;
1192,1193c1853,1855
<         // Set market's comptroller to newComptroller
<         comptroller = newComptroller;
---
>             // Emit event
>             emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);
>         }
1195,1196c1857,1865
<         // Emit NewComptroller(oldComptroller, newComptroller)
<         emit NewComptroller(oldComptroller, newComptroller);
---
>         // If setting Fuse fee
>         if (fuseFeeMantissa != newFuseFeeMantissa) {
>             // Set Fuse fee
>             uint256 oldFuseFeeMantissa = fuseFeeMantissa;
>             fuseFeeMantissa = newFuseFeeMantissa;
> 
>             // Emit event
>             emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);
>         }
1198c1867
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
1202,1208c1871,1881
<       * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
<       * @dev Admin function to accrue interest and set a new reserve factor
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
>      * @dev Admin function to accrue interest and set a new reserve factor
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setReserveFactor(uint256 newReserveFactorMantissa)
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
1210c1883,1887
<             return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
---
>             return
>                 fail(
>                     Error(error),
>                     FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED
>                 );
1217,1221c1894,1901
<       * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
<       * @dev Admin function to set a new reserve factor
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
---
>      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
>      * @dev Admin function to set a new reserve factor
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setReserveFactorFresh(uint256 newReserveFactorMantissa)
>         internal
>         returns (uint256)
>     {
1223,1224c1903,1908
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK
>                 );
1229c1913,1917
<             return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK
>                 );
1233,1234c1921,1931
<         if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
<             return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
---
>         if (
>             add_(
>                 add_(newReserveFactorMantissa, adminFeeMantissa),
>                 fuseFeeMantissa
>             ) > reserveFactorPlusFeesMaxMantissa
>         ) {
>             return
>                 fail(
>                     Error.BAD_INPUT,
>                     FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK
>                 );
1237c1934
<         uint oldReserveFactorMantissa = reserveFactorMantissa;
---
>         uint256 oldReserveFactorMantissa = reserveFactorMantissa;
1240c1937,1940
<         emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
---
>         emit NewReserveFactor(
>             oldReserveFactorMantissa,
>             newReserveFactorMantissa
>         );
1242c1942
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
1246,1247c1946,1947
<      * @notice Accrues interest and reduces reserves by transferring from msg.sender
<      * @param addAmount Amount of addition to reserves
---
>      * @notice Accrues interest and reduces reserves by transferring to admin
>      * @param reduceAmount Amount of reduction to reserves
1250,1252c1950,1956
<     function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function _reduceReserves(uint256 reduceAmount)
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
1254c1958,1962
<             return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);
---
>             return
>                 fail(
>                     Error(error),
>                     FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED
>                 );
1256,1259c1964,1965
< 
<         // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.
<         (error, ) = _addReservesFresh(addAmount);
<         return error;
---
>         // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
>         return _reduceReservesFresh(reduceAmount);
1263c1969
<      * @notice Add reserves by transferring from caller
---
>      * @notice Reduces reserves by transferring to admin
1265,1266c1971,1972
<      * @param addAmount Amount of addition to reserves
<      * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees
---
>      * @param reduceAmount Amount of reduction to reserves
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
1268,1271c1974,1988
<     function _addReservesFresh(uint addAmount) internal returns (uint, uint) {
<         // totalReserves + actualAddAmount
<         uint totalReservesNew;
<         uint actualAddAmount;
---
>     function _reduceReservesFresh(uint256 reduceAmount)
>         internal
>         returns (uint256)
>     {
>         // totalReserves - reduceAmount
>         uint256 totalReservesNew;
> 
>         // Check caller is admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.REDUCE_RESERVES_ADMIN_CHECK
>                 );
>         }
1275c1992,2011
<             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.REDUCE_RESERVES_FRESH_CHECK
>                 );
>         }
> 
>         // Fail gracefully if protocol has insufficient underlying cash
>         if (getCashPrior() < reduceAmount) {
>             return
>                 fail(
>                     Error.TOKEN_INSUFFICIENT_CASH,
>                     FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE
>                 );
>         }
> 
>         // Check reduceAmount ≤ reserves[n] (totalReserves)
>         if (reduceAmount > totalReserves) {
>             return
>                 fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
1282,1295c2018,2019
<         /*
<          * We call doTransferIn for the caller and the addAmount
<          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
<          *  On success, the cToken holds an additional addAmount of cash.
<          *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.
<          *  it returns the amount actually transferred, in case of a fee.
<          */
< 
<         actualAddAmount = doTransferIn(msg.sender, addAmount);
< 
<         totalReservesNew = totalReserves + actualAddAmount;
< 
<         /* Revert on overflow */
<         require(totalReservesNew >= totalReserves, "add reserves unexpected overflow");
---
>         // We checked reduceAmount <= totalReserves above, so this should never revert.
>         totalReservesNew = sub_(totalReserves, reduceAmount);
1297c2021
<         // Store reserves[n+1] = reserves[n] + actualAddAmount
---
>         // Store reserves[n+1] = reserves[n] - reduceAmount
1300,1301c2024,2025
<         /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */
<         emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
---
>         // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
>         doTransferOut(msg.sender, reduceAmount);
1303,1305c2027
<         /* Return (NO_ERROR, actualAddAmount) */
<         return (uint(Error.NO_ERROR), actualAddAmount);
<     }
---
>         emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);
1306a2029,2030
>         return uint256(Error.NO_ERROR);
>     }
1309,1310c2033,2034
<      * @notice Accrues interest and reduces reserves by transferring to admin
<      * @param reduceAmount Amount of reduction to reserves
---
>      * @notice Accrues interest and reduces Fuse fees by transferring to Fuse
>      * @param withdrawAmount Amount of fees to withdraw
1313,1317c2037,2049
<     function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
<             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
<             return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
---
>     function _withdrawFuseFees(uint256 withdrawAmount)
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
>             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.
>             return
>                 fail(
>                     Error(error),
>                     FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED
>                 );
1319,1320c2051,2052
<         // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
<         return _reduceReservesFresh(reduceAmount);
---
>         // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
>         return _withdrawFuseFeesFresh(withdrawAmount);
1324c2056
<      * @notice Reduces reserves by transferring to admin
---
>      * @notice Reduces Fuse fees by transferring to Fuse
1326c2058
<      * @param reduceAmount Amount of reduction to reserves
---
>      * @param withdrawAmount Amount of fees to withdraw
1329,1331c2061,2066
<     function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
<         // totalReserves - reduceAmount
<         uint totalReservesNew;
---
>     function _withdrawFuseFeesFresh(uint256 withdrawAmount)
>         internal
>         returns (uint256)
>     {
>         // totalFuseFees - reduceAmount
>         uint256 totalFuseFeesNew;
1333,1335c2068,2074
<         // Check caller is admin
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
---
>         // We fail gracefully unless market's block number equals current block number
>         if (accrualBlockNumber != getBlockNumber()) {
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK
>                 );
1337a2077,2146
>         // Fail gracefully if protocol has insufficient underlying cash
>         if (getCashPrior() < withdrawAmount) {
>             return
>                 fail(
>                     Error.TOKEN_INSUFFICIENT_CASH,
>                     FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE
>                 );
>         }
> 
>         // Check withdrawAmount ≤ fuseFees[n] (totalFuseFees)
>         if (withdrawAmount > totalFuseFees) {
>             return
>                 fail(
>                     Error.BAD_INPUT,
>                     FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION
>                 );
>         }
> 
>         /////////////////////////
>         // EFFECTS & INTERACTIONS
>         // (No safe failures beyond this point)
> 
>         // We checked withdrawAmount <= totalFuseFees above, so this should never revert.
>         totalFuseFeesNew = sub_(totalFuseFees, withdrawAmount);
> 
>         // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount
>         totalFuseFees = totalFuseFeesNew;
> 
>         // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
>         doTransferOut(address(fuseAdmin), withdrawAmount);
> 
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice Accrues interest and reduces admin fees by transferring to admin
>      * @param withdrawAmount Amount of fees to withdraw
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _withdrawAdminFees(uint256 withdrawAmount)
>         external
>         nonReentrant(false)
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
>             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.
>             return
>                 fail(
>                     Error(error),
>                     FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED
>                 );
>         }
>         // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
>         return _withdrawAdminFeesFresh(withdrawAmount);
>     }
> 
>     /**
>      * @notice Reduces admin fees by transferring to admin
>      * @dev Requires fresh interest accrual
>      * @param withdrawAmount Amount of fees to withdraw
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _withdrawAdminFeesFresh(uint256 withdrawAmount)
>         internal
>         returns (uint256)
>     {
>         // totalAdminFees - reduceAmount
>         uint256 totalAdminFeesNew;
> 
1340c2149,2153
<             return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK
>                 );
1344,1345c2157,2162
<         if (getCashPrior() < reduceAmount) {
<             return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
---
>         if (getCashPrior() < withdrawAmount) {
>             return
>                 fail(
>                     Error.TOKEN_INSUFFICIENT_CASH,
>                     FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE
>                 );
1348,1350c2165,2171
<         // Check reduceAmount ≤ reserves[n] (totalReserves)
<         if (reduceAmount > totalReserves) {
<             return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
---
>         // Check withdrawAmount ≤ adminFees[n] (totalAdminFees)
>         if (withdrawAmount > totalAdminFees) {
>             return
>                 fail(
>                     Error.BAD_INPUT,
>                     FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION
>                 );
1357,1359c2178,2179
<         totalReservesNew = totalReserves - reduceAmount;
<         // We checked reduceAmount <= totalReserves above, so this should never revert.
<         require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");
---
>         // We checked withdrawAmount <= totalAdminFees above, so this should never revert.
>         totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);
1361,1362c2181,2182
<         // Store reserves[n+1] = reserves[n] - reduceAmount
<         totalReserves = totalReservesNew;
---
>         // Store adminFees[n+1] = adminFees[n] - withdrawAmount
>         totalAdminFees = totalAdminFeesNew;
1365c2185,2190
<         doTransferOut(admin, reduceAmount);
---
>         doTransferOut(
>             address(
>                 uint160(UnitrollerAdminStorage(address(comptroller)).admin())
>             ),
>             withdrawAmount
>         );
1367,1369c2192
<         emit ReservesReduced(admin, reduceAmount, totalReservesNew);
< 
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
1378,1380c2201,2206
<     function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
<         uint error = accrueInterest();
<         if (error != uint(Error.NO_ERROR)) {
---
>     function _setInterestRateModel(InterestRateModel newInterestRateModel)
>         public
>         returns (uint256)
>     {
>         uint256 error = accrueInterest();
>         if (error != uint256(Error.NO_ERROR)) {
1382c2208,2212
<             return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
---
>             return
>                 fail(
>                     Error(error),
>                     FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED
>                 );
1394,1395c2224,2227
<     function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {
< 
---
>     function _setInterestRateModelFresh(InterestRateModel newInterestRateModel)
>         internal
>         returns (uint256)
>     {
1400,1401c2232,2237
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK
>                 );
1406c2242,2246
<             return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
---
>             return
>                 fail(
>                     Error.MARKET_NOT_FRESH,
>                     FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK
>                 );
1413c2253,2256
<         require(newInterestRateModel.isInterestRateModel(), "marker method returned false");
---
>         require(
>             newInterestRateModel.isInterestRateModel(),
>             "marker method returned false"
>         );
1419c2262,2292
<         emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);
---
>         emit NewMarketInterestRateModel(
>             oldInterestRateModel,
>             newInterestRateModel
>         );
> 
>         // Attempt to reset interest checkpoints on old IRM
>         if (address(oldInterestRateModel) != address(0))
>             address(oldInterestRateModel).call(
>                 abi.encodeWithSignature("resetInterestCheckpoints()")
>             );
> 
>         // Attempt to add first interest checkpoint on new IRM
>         address(newInterestRateModel).call(
>             abi.encodeWithSignature("checkpointInterest()")
>         );
> 
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice updates the cToken ERC20 name and symbol
>      * @dev Admin function to update the cToken ERC20 name and symbol
>      * @param _name the new ERC20 token name to use
>      * @param _symbol the new ERC20 token symbol to use
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setNameAndSymbol(string calldata _name, string calldata _symbol)
>         external
>     {
>         // Check caller is admin
>         require(hasAdminRights(), "caller not admin");
1421c2294,2296
<         return uint(Error.NO_ERROR);
---
>         // Set ERC20 name and symbol
>         name = _name;
>         symbol = _symbol;
1431c2306
<     function getCashPrior() internal view returns (uint);
---
>     function getCashPrior() internal view returns (uint256);
1437c2312,2314
<     function doTransferIn(address from, uint amount) internal returns (uint);
---
>     function doTransferIn(address from, uint256 amount)
>         internal
>         returns (uint256);
1444,1445c2321
<     function doTransferOut(address payable to, uint amount) internal;
< 
---
>     function doTransferOut(address payable to, uint256 amount) internal;
1452c2328,2339
<     modifier nonReentrant() {
---
>     modifier nonReentrant(bool localOnly) {
>         _beforeNonReentrant(localOnly);
>         _;
>         _afterNonReentrant(localOnly);
>     }
> 
>     /**
>      * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.
>      * Saves space because function modifier code is "inlined" into every function with the modifier).
>      * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.
>      */
>     function _beforeNonReentrant(bool localOnly) private {
1453a2341
>         if (!localOnly) comptroller._beforeNonReentrant();
1455c2343,2350
<         _;
---
>     }
> 
>     /**
>      * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.
>      * Saves space because function modifier code is "inlined" into every function with the modifier).
>      * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.
>      */
>     function _afterNonReentrant(bool localOnly) private {
1456a2352,2388
>         if (!localOnly) comptroller._afterNonReentrant();
>     }
> 
>     /**
>      * @dev Performs a Solidity function call using a low level `call`. A
>      * plain `call` is an unsafe replacement for a function call: use this
>      * function instead.
>      * If `target` reverts with a revert reason, it is bubbled up by this
>      * function (like regular Solidity function calls).
>      * Returns the raw returned data. To convert to the expected return value,
>      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
>      * @param data The call data (encoded using abi.encode or one of its variants).
>      * @param errorMessage The revert string to return on failure.
>      */
>     function _functionCall(
>         address target,
>         bytes memory data,
>         string memory errorMessage
>     ) internal returns (bytes memory) {
>         (bool success, bytes memory returndata) = target.call(data);
> 
>         if (!success) {
>             // Look for revert reason and bubble it up if present
>             if (returndata.length > 0) {
>                 // The easiest way to bubble the revert reason is using memory via assembly
> 
>                 // solhint-disable-next-line no-inline-assembly
>                 assembly {
>                     let returndata_size := mload(returndata)
>                     revert(add(32, returndata), returndata_size)
>                 }
>             } else {
>                 revert(errorMessage);
>             }
>         }
> 
>         return returndata;
Only in src/core/: DAIInterestRateModelV2.sol
Only in ../compound-protocol/contracts/: DAIInterestRateModelV3.sol
diff -x .git -r ../compound-protocol/contracts/EIP20Interface.sol src/core/EIP20Interface.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
8a9
> 
9a11
> 
13,15c15,17
<       * @notice Get the total number of tokens in circulation
<       * @return The supply of tokens
<       */
---
>      * @notice Get the total number of tokens in circulation
>      * @return The supply of tokens
>      */
26,58c28,71
<       * @notice Transfer `amount` tokens from `msg.sender` to `dst`
<       * @param dst The address of the destination account
<       * @param amount The number of tokens to transfer
<       * @return Whether or not the transfer succeeded
<       */
<     function transfer(address dst, uint256 amount) external returns (bool success);
< 
<     /**
<       * @notice Transfer `amount` tokens from `src` to `dst`
<       * @param src The address of the source account
<       * @param dst The address of the destination account
<       * @param amount The number of tokens to transfer
<       * @return Whether or not the transfer succeeded
<       */
<     function transferFrom(address src, address dst, uint256 amount) external returns (bool success);
< 
<     /**
<       * @notice Approve `spender` to transfer up to `amount` from `src`
<       * @dev This will overwrite the approval amount for `spender`
<       *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
<       * @param spender The address of the account which may transfer tokens
<       * @param amount The number of tokens that are approved (-1 means infinite)
<       * @return Whether or not the approval succeeded
<       */
<     function approve(address spender, uint256 amount) external returns (bool success);
< 
<     /**
<       * @notice Get the current allowance from `owner` for `spender`
<       * @param owner The address of the account which owns the tokens to be spent
<       * @param spender The address of the account which may transfer tokens
<       * @return The number of tokens allowed to be spent (-1 means infinite)
<       */
<     function allowance(address owner, address spender) external view returns (uint256 remaining);
---
>      * @notice Transfer `amount` tokens from `msg.sender` to `dst`
>      * @param dst The address of the destination account
>      * @param amount The number of tokens to transfer
>      * @return Whether or not the transfer succeeded
>      */
>     function transfer(address dst, uint256 amount)
>         external
>         returns (bool success);
> 
>     /**
>      * @notice Transfer `amount` tokens from `src` to `dst`
>      * @param src The address of the source account
>      * @param dst The address of the destination account
>      * @param amount The number of tokens to transfer
>      * @return Whether or not the transfer succeeded
>      */
>     function transferFrom(
>         address src,
>         address dst,
>         uint256 amount
>     ) external returns (bool success);
> 
>     /**
>      * @notice Approve `spender` to transfer up to `amount` from `src`
>      * @dev This will overwrite the approval amount for `spender`
>      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
>      * @param spender The address of the account which may transfer tokens
>      * @param amount The number of tokens that are approved (-1 means infinite)
>      * @return Whether or not the approval succeeded
>      */
>     function approve(address spender, uint256 amount)
>         external
>         returns (bool success);
> 
>     /**
>      * @notice Get the current allowance from `owner` for `spender`
>      * @param owner The address of the account which owns the tokens to be spent
>      * @param spender The address of the account which may transfer tokens
>      * @return The number of tokens allowed to be spent (-1 means infinite)
>      */
>     function allowance(address owner, address spender)
>         external
>         view
>         returns (uint256 remaining);
61c74,78
<     event Approval(address indexed owner, address indexed spender, uint256 amount);
---
>     event Approval(
>         address indexed owner,
>         address indexed spender,
>         uint256 amount
>     );
diff -x .git -r ../compound-protocol/contracts/EIP20NonStandardInterface.sol src/core/EIP20NonStandardInterface.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
9d8
< 
30,33c29,32
<       * @notice Transfer `amount` tokens from `msg.sender` to `dst`
<       * @param dst The address of the destination account
<       * @param amount The number of tokens to transfer
<       */
---
>      * @notice Transfer `amount` tokens from `msg.sender` to `dst`
>      * @param dst The address of the destination account
>      * @param amount The number of tokens to transfer
>      */
43,66c42,74
<       * @notice Transfer `amount` tokens from `src` to `dst`
<       * @param src The address of the source account
<       * @param dst The address of the destination account
<       * @param amount The number of tokens to transfer
<       */
<     function transferFrom(address src, address dst, uint256 amount) external;
< 
<     /**
<       * @notice Approve `spender` to transfer up to `amount` from `src`
<       * @dev This will overwrite the approval amount for `spender`
<       *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
<       * @param spender The address of the account which may transfer tokens
<       * @param amount The number of tokens that are approved
<       * @return Whether or not the approval succeeded
<       */
<     function approve(address spender, uint256 amount) external returns (bool success);
< 
<     /**
<       * @notice Get the current allowance from `owner` for `spender`
<       * @param owner The address of the account which owns the tokens to be spent
<       * @param spender The address of the account which may transfer tokens
<       * @return The number of tokens allowed to be spent
<       */
<     function allowance(address owner, address spender) external view returns (uint256 remaining);
---
>      * @notice Transfer `amount` tokens from `src` to `dst`
>      * @param src The address of the source account
>      * @param dst The address of the destination account
>      * @param amount The number of tokens to transfer
>      */
>     function transferFrom(
>         address src,
>         address dst,
>         uint256 amount
>     ) external;
> 
>     /**
>      * @notice Approve `spender` to transfer up to `amount` from `src`
>      * @dev This will overwrite the approval amount for `spender`
>      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
>      * @param spender The address of the account which may transfer tokens
>      * @param amount The number of tokens that are approved
>      * @return Whether or not the approval succeeded
>      */
>     function approve(address spender, uint256 amount)
>         external
>         returns (bool success);
> 
>     /**
>      * @notice Get the current allowance from `owner` for `spender`
>      * @param owner The address of the account which owns the tokens to be spent
>      * @param spender The address of the account which may transfer tokens
>      * @return The number of tokens allowed to be spent
>      */
>     function allowance(address owner, address spender)
>         external
>         view
>         returns (uint256 remaining);
69c77,81
<     event Approval(address indexed owner, address indexed spender, uint256 amount);
---
>     event Approval(
>         address indexed owner,
>         address indexed spender,
>         uint256 amount
>     );
diff -x .git -r ../compound-protocol/contracts/ErrorReporter.sol src/core/ErrorReporter.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
22c22,26
<         TOO_MUCH_REPAY
---
>         TOO_MUCH_REPAY,
>         SUPPLIER_NOT_WHITELISTED,
>         BORROW_BELOW_MIN,
>         SUPPLY_ABOVE_MAX,
>         NONZERO_TOTAL_SUPPLY
27a32
>         ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,
29a35,36
>         TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,
>         TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,
36d42
<         SET_IMPLEMENTATION_OWNER_CHECK,
40a47
>         SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,
42a50,51
>         SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,
>         SET_WHITELIST_STATUS_OWNER_CHECK,
45c54,57
<         SET_PAUSE_GUARDIAN_OWNER_CHECK
---
>         SET_PAUSE_GUARDIAN_OWNER_CHECK,
>         UNSUPPORT_MARKET_OWNER_CHECK,
>         UNSUPPORT_MARKET_DOES_NOT_EXIST,
>         UNSUPPORT_MARKET_IN_USE
49,52c61,64
<       * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
<       * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
<       **/
<     event Failure(uint error, uint info, uint detail);
---
>      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
>      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
>      **/
>     event Failure(uint256 error, uint256 info, uint256 detail);
55,58c67,70
<       * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
<       */
<     function fail(Error err, FailureInfo info) internal returns (uint) {
<         emit Failure(uint(err), uint(info), 0);
---
>      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
>      */
>     function fail(Error err, FailureInfo info) internal returns (uint256) {
>         emit Failure(uint256(err), uint256(info), 0);
60c72
<         return uint(err);
---
>         return uint256(err);
64,67c76,83
<       * @dev use this when reporting an opaque error from an upgradeable collaborator contract
<       */
<     function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {
<         emit Failure(uint(err), uint(info), opaqueError);
---
>      * @dev use this when reporting an opaque error from an upgradeable collaborator contract
>      */
>     function failOpaque(
>         Error err,
>         FailureInfo info,
>         uint256 opaqueError
>     ) internal returns (uint256) {
>         emit Failure(uint256(err), uint256(info), opaqueError);
69c85
<         return uint(err);
---
>         return uint256(err);
91c107,108
<         TOKEN_TRANSFER_OUT_FAILED
---
>         TOKEN_TRANSFER_OUT_FAILED,
>         UTILIZATION_ABOVE_MAX
106a124,125
>         ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED,
>         ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,
139a159
>         NEW_UTILIZATION_RATE_ABOVE_MAX,
148a169,176
>         WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED,
>         WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE,
>         WITHDRAW_FUSE_FEES_FRESH_CHECK,
>         WITHDRAW_FUSE_FEES_VALIDATION,
>         WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,
>         WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,
>         WITHDRAW_ADMIN_FEES_FRESH_CHECK,
>         WITHDRAW_ADMIN_FEES_VALIDATION,
169a198
>         TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,
170a200,206
>         SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,
>         SET_ADMIN_FEE_ADMIN_CHECK,
>         SET_ADMIN_FEE_FRESH_CHECK,
>         SET_ADMIN_FEE_BOUNDS_CHECK,
>         SET_FUSE_FEE_ACCRUE_INTEREST_FAILED,
>         SET_FUSE_FEE_FRESH_CHECK,
>         SET_FUSE_FEE_BOUNDS_CHECK,
185,188c221,224
<       * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
<       * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
<       **/
<     event Failure(uint error, uint info, uint detail);
---
>      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
>      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
>      **/
>     event Failure(uint256 error, uint256 info, uint256 detail);
191,194c227,230
<       * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
<       */
<     function fail(Error err, FailureInfo info) internal returns (uint) {
<         emit Failure(uint(err), uint(info), 0);
---
>      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
>      */
>     function fail(Error err, FailureInfo info) internal returns (uint256) {
>         emit Failure(uint256(err), uint256(info), 0);
196c232
<         return uint(err);
---
>         return uint256(err);
200,205c236,248
<       * @dev use this when reporting an opaque error from an upgradeable collaborator contract
<       */
<     function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {
<         emit Failure(uint(err), uint(info), opaqueError);
< 
<         return uint(err);
---
>      * @dev use this when reporting an opaque error from an upgradeable collaborator contract
>      */
>     function failOpaque(
>         Error err,
>         FailureInfo info,
>         uint256 opaqueError
>     ) internal returns (uint256) {
>         emit Failure(uint256(err), uint256(info), opaqueError);
> 
>         return
>             err == Error.COMPTROLLER_REJECTION
>                 ? 1000 + opaqueError
>                 : uint256(err);
207c250
< }
\ No newline at end of file
---
> }
diff -x .git -r ../compound-protocol/contracts/ExponentialNoError.sol src/core/ExponentialNoError.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
11,14c11,14
<     uint constant expScale = 1e18;
<     uint constant doubleScale = 1e36;
<     uint constant halfExpScale = expScale/2;
<     uint constant mantissaOne = expScale;
---
>     uint256 constant expScale = 1e18;
>     uint256 constant doubleScale = 1e36;
>     uint256 constant halfExpScale = expScale / 2;
>     uint256 constant mantissaOne = expScale;
17c17
<         uint mantissa;
---
>         uint256 mantissa;
21c21
<         uint mantissa;
---
>         uint256 mantissa;
28c28
<     function truncate(Exp memory exp) pure internal returns (uint) {
---
>     function truncate(Exp memory exp) internal pure returns (uint256) {
36c36,40
<     function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {
---
>     function mul_ScalarTruncate(Exp memory a, uint256 scalar)
>         internal
>         pure
>         returns (uint256)
>     {
44c48,52
<     function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {
---
>     function mul_ScalarTruncateAddUInt(
>         Exp memory a,
>         uint256 scalar,
>         uint256 addend
>     ) internal pure returns (uint256) {
52c60,64
<     function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {
---
>     function lessThanExp(Exp memory left, Exp memory right)
>         internal
>         pure
>         returns (bool)
>     {
59c71,75
<     function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {
---
>     function lessThanOrEqualExp(Exp memory left, Exp memory right)
>         internal
>         pure
>         returns (bool)
>     {
66c82,86
<     function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {
---
>     function greaterThanExp(Exp memory left, Exp memory right)
>         internal
>         pure
>         returns (bool)
>     {
73c93
<     function isZeroExp(Exp memory value) pure internal returns (bool) {
---
>     function isZeroExp(Exp memory value) internal pure returns (bool) {
77c97,101
<     function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {
---
>     function safe224(uint256 n, string memory errorMessage)
>         internal
>         pure
>         returns (uint224)
>     {
82c106,110
<     function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {
---
>     function safe32(uint256 n, string memory errorMessage)
>         internal
>         pure
>         returns (uint32)
>     {
87c115,119
<     function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
---
>     function add_(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (Exp memory)
>     {
91c123,127
<     function add_(Double memory a, Double memory b) pure internal returns (Double memory) {
---
>     function add_(Double memory a, Double memory b)
>         internal
>         pure
>         returns (Double memory)
>     {
95c131
<     function add_(uint a, uint b) pure internal returns (uint) {
---
>     function add_(uint256 a, uint256 b) internal pure returns (uint256) {
99,100c135,140
<     function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {
<         uint c = a + b;
---
>     function add_(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
>         uint256 c = a + b;
105c145,149
<     function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
---
>     function sub_(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (Exp memory)
>     {
109c153,157
<     function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {
---
>     function sub_(Double memory a, Double memory b)
>         internal
>         pure
>         returns (Double memory)
>     {
113c161
<     function sub_(uint a, uint b) pure internal returns (uint) {
---
>     function sub_(uint256 a, uint256 b) internal pure returns (uint256) {
117c165,169
<     function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {
---
>     function sub_(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
122c174,178
<     function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
---
>     function mul_(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (Exp memory)
>     {
126c182
<     function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {
---
>     function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {
130c186
<     function mul_(uint a, Exp memory b) pure internal returns (uint) {
---
>     function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {
134c190,194
<     function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {
---
>     function mul_(Double memory a, Double memory b)
>         internal
>         pure
>         returns (Double memory)
>     {
138c198,202
<     function mul_(Double memory a, uint b) pure internal returns (Double memory) {
---
>     function mul_(Double memory a, uint256 b)
>         internal
>         pure
>         returns (Double memory)
>     {
142c206
<     function mul_(uint a, Double memory b) pure internal returns (uint) {
---
>     function mul_(uint256 a, Double memory b) internal pure returns (uint256) {
146c210
<     function mul_(uint a, uint b) pure internal returns (uint) {
---
>     function mul_(uint256 a, uint256 b) internal pure returns (uint256) {
150c214,218
<     function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {
---
>     function mul_(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
154c222
<         uint c = a * b;
---
>         uint256 c = a * b;
159c227,231
<     function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
---
>     function div_(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (Exp memory)
>     {
163c235
<     function div_(Exp memory a, uint b) pure internal returns (Exp memory) {
---
>     function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {
167c239
<     function div_(uint a, Exp memory b) pure internal returns (uint) {
---
>     function div_(uint256 a, Exp memory b) internal pure returns (uint256) {
171,172c243,249
<     function div_(Double memory a, Double memory b) pure internal returns (Double memory) {
<         return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});
---
>     function div_(Double memory a, Double memory b)
>         internal
>         pure
>         returns (Double memory)
>     {
>         return
>             Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});
175c252,256
<     function div_(Double memory a, uint b) pure internal returns (Double memory) {
---
>     function div_(Double memory a, uint256 b)
>         internal
>         pure
>         returns (Double memory)
>     {
179c260
<     function div_(uint a, Double memory b) pure internal returns (uint) {
---
>     function div_(uint256 a, Double memory b) internal pure returns (uint256) {
183c264
<     function div_(uint a, uint b) pure internal returns (uint) {
---
>     function div_(uint256 a, uint256 b) internal pure returns (uint256) {
187c268,272
<     function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {
---
>     function div_(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
192c277,281
<     function fraction(uint a, uint b) pure internal returns (Double memory) {
---
>     function fraction(uint256 a, uint256 b)
>         internal
>         pure
>         returns (Double memory)
>     {
diff -x .git -r ../compound-protocol/contracts/Exponential.sol src/core/Exponential.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
20,21c20,25
<     function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {
<         (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);
---
>     function getExp(uint256 num, uint256 denom)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
>         (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);
26c30
<         (MathError err1, uint rational) = divUInt(scaledNumerator, denom);
---
>         (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);
37,38c41,46
<     function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {
<         (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);
---
>     function addExp(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
>         (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);
46,47c54,59
<     function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {
<         (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);
---
>     function subExp(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
>         (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);
55,56c67,72
<     function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {
<         (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);
---
>     function mulScalar(Exp memory a, uint256 scalar)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
>         (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);
67c83,87
<     function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {
---
>     function mulScalarTruncate(Exp memory a, uint256 scalar)
>         internal
>         pure
>         returns (MathError, uint256)
>     {
79c99,103
<     function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {
---
>     function mulScalarTruncateAddUInt(
>         Exp memory a,
>         uint256 scalar,
>         uint256 addend
>     ) internal pure returns (MathError, uint256) {
91,92c115,123
<     function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {
<         (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);
---
>     function divScalar(Exp memory a, uint256 scalar)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
>         (MathError err0, uint256 descaledMantissa) = divUInt(
>             a.mantissa,
>             scalar
>         );
103c134,138
<     function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {
---
>     function divScalarByExp(uint256 scalar, Exp memory divisor)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
113c148
<         (MathError err0, uint numerator) = mulUInt(expScale, scalar);
---
>         (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);
123c158,162
<     function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {
---
>     function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)
>         internal
>         pure
>         returns (MathError, uint256)
>     {
135,137c174,182
<     function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {
< 
<         (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);
---
>     function mulExp(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
>         (MathError err0, uint256 doubleScaledProduct) = mulUInt(
>             a.mantissa,
>             b.mantissa
>         );
145c190,193
<         (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);
---
>         (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(
>             halfExpScale,
>             doubleScaledProduct
>         );
150c198,201
<         (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);
---
>         (MathError err2, uint256 product) = divUInt(
>             doubleScaledProductWithHalfScale,
>             expScale
>         );
160c211,215
<     function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {
---
>     function mulExp(uint256 a, uint256 b)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
167c222,226
<     function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {
---
>     function mulExp3(
>         Exp memory a,
>         Exp memory b,
>         Exp memory c
>     ) internal pure returns (MathError, Exp memory) {
180c239,243
<     function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {
---
>     function divExp(Exp memory a, Exp memory b)
>         internal
>         pure
>         returns (MathError, Exp memory)
>     {
Only in src/core/: governance
Only in ../compound-protocol/contracts/: Governance
Only in src/core/: IFuseFeeDistributor.sol
diff -x .git -r ../compound-protocol/contracts/InterestRateModel.sol src/core/InterestRateModel.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
4,6c4,6
<   * @title Compound's InterestRateModel Interface
<   * @author Compound
<   */
---
>  * @title Compound's InterestRateModel Interface
>  * @author Compound
>  */
12,18c12,22
<       * @notice Calculates the current borrow interest rate per block
<       * @param cash The total amount of cash the market has
<       * @param borrows The total amount of borrows the market has outstanding
<       * @param reserves The total amount of reserves the market has
<       * @return The borrow rate per block (as a percentage, and scaled by 1e18)
<       */
<     function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);
---
>      * @notice Calculates the current borrow interest rate per block
>      * @param cash The total amount of cash the market has
>      * @param borrows The total amount of borrows the market has outstanding
>      * @param reserves The total amount of reserves the market has
>      * @return The borrow rate per block (as a percentage, and scaled by 1e18)
>      */
>     function getBorrowRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) external view returns (uint256);
21,29c25,37
<       * @notice Calculates the current supply interest rate per block
<       * @param cash The total amount of cash the market has
<       * @param borrows The total amount of borrows the market has outstanding
<       * @param reserves The total amount of reserves the market has
<       * @param reserveFactorMantissa The current reserve factor the market has
<       * @return The supply rate per block (as a percentage, and scaled by 1e18)
<       */
<     function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);
< 
---
>      * @notice Calculates the current supply interest rate per block
>      * @param cash The total amount of cash the market has
>      * @param borrows The total amount of borrows the market has outstanding
>      * @param reserves The total amount of reserves the market has
>      * @param reserveFactorMantissa The current reserve factor the market has
>      * @return The supply rate per block (as a percentage, and scaled by 1e18)
>      */
>     function getSupplyRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves,
>         uint256 reserveFactorMantissa
>     ) external view returns (uint256);
diff -x .git -r ../compound-protocol/contracts/JumpRateModel.sol src/core/JumpRateModel.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
7,9c7,9
<   * @title Compound's JumpRateModel Contract
<   * @author Compound
<   */
---
>  * @title Compound's JumpRateModel Contract
>  * @author Compound
>  */
11c11
<     using SafeMath for uint;
---
>     using SafeMath for uint256;
13c13,18
<     event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);
---
>     event NewInterestParams(
>         uint256 baseRatePerBlock,
>         uint256 multiplierPerBlock,
>         uint256 jumpMultiplierPerBlock,
>         uint256 kink
>     );
18c23
<     uint public constant blocksPerYear = 2102400;
---
>     uint256 public constant blocksPerYear = 2372500; // 6500 blocks/day * 365 days/year
23c28
<     uint public multiplierPerBlock;
---
>     uint256 public multiplierPerBlock;
28c33
<     uint public baseRatePerBlock;
---
>     uint256 public baseRatePerBlock;
33c38
<     uint public jumpMultiplierPerBlock;
---
>     uint256 public jumpMultiplierPerBlock;
38c43
<     uint public kink;
---
>     uint256 public kink;
47c52,57
<     constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) public {
---
>     constructor(
>         uint256 baseRatePerYear,
>         uint256 multiplierPerYear,
>         uint256 jumpMultiplierPerYear,
>         uint256 kink_
>     ) public {
53c63,68
<         emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);
---
>         emit NewInterestParams(
>             baseRatePerBlock,
>             multiplierPerBlock,
>             jumpMultiplierPerBlock,
>             kink
>         );
63c78,82
<     function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {
---
>     function utilizationRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) public pure returns (uint256) {
79,80c98,103
<     function getBorrowRate(uint cash, uint borrows, uint reserves) public view returns (uint) {
<         uint util = utilizationRate(cash, borrows, reserves);
---
>     function getBorrowRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) public view returns (uint256) {
>         uint256 util = utilizationRate(cash, borrows, reserves);
85,87c108,115
<             uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
<             uint excessUtil = util.sub(kink);
<             return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
---
>             uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(
>                 baseRatePerBlock
>             );
>             uint256 excessUtil = util.sub(kink);
>             return
>                 excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(
>                     normalRate
>                 );
99,103c127,139
<     function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {
<         uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);
<         uint borrowRate = getBorrowRate(cash, borrows, reserves);
<         uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
<         return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
---
>     function getSupplyRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves,
>         uint256 reserveFactorMantissa
>     ) public view returns (uint256) {
>         uint256 oneMinusReserveFactor = uint256(1e18).sub(
>             reserveFactorMantissa
>         );
>         uint256 borrowRate = getBorrowRate(cash, borrows, reserves);
>         uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
>         return
>             utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
diff -x .git -r ../compound-protocol/contracts/JumpRateModelV2.sol src/core/JumpRateModelV2.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
6d5
< 
8,14c7,12
<   * @title Compound's JumpRateModel Contract V2 for V2 cTokens
<   * @author Arr00
<   * @notice Supports only for V2 cTokens
<   */
< contract JumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2  {
< 
< 	/**
---
>  * @title Compound's JumpRateModel Contract V2 for V2 cTokens
>  * @author Arr00
>  * @notice Supports only for V2 cTokens
>  */
> contract JumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2 {
>     /**
21c19,23
<     function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint) {
---
>     function getBorrowRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) external view returns (uint256) {
25,26c27,42
<     constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) 
<     	BaseJumpRateModelV2(baseRatePerYear,multiplierPerYear,jumpMultiplierPerYear,kink_,owner_) public {}
---
>     constructor(
>         uint256 baseRatePerYear,
>         uint256 multiplierPerYear,
>         uint256 jumpMultiplierPerYear,
>         uint256 kink_,
>         address owner_
>     )
>         public
>         BaseJumpRateModelV2(
>             baseRatePerYear,
>             multiplierPerYear,
>             jumpMultiplierPerYear,
>             kink_,
>             owner_
>         )
>     {}
Only in ../compound-protocol/contracts/: LegacyInterestRateModel.sol
Only in ../compound-protocol/contracts/: LegacyJumpRateModelV2.sol
Only in src/core/: lens
Only in ../compound-protocol/contracts/: Lens
diff -x .git -r ../compound-protocol/contracts/Maximillion.sol src/core/Maximillion.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
37,39c37,42
<     function repayBehalfExplicit(address borrower, CEther cEther_) public payable {
<         uint received = msg.value;
<         uint borrows = cEther_.borrowBalanceCurrent(borrower);
---
>     function repayBehalfExplicit(address borrower, CEther cEther_)
>         public
>         payable
>     {
>         uint256 received = msg.value;
>         uint256 borrows = cEther_.borrowBalanceCurrent(borrower);
diff -x .git -r ../compound-protocol/contracts/PriceOracle.sol src/core/PriceOracle.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
10,15c10,15
<       * @notice Get the underlying price of a cToken asset
<       * @param cToken The cToken to get the underlying price of
<       * @return The underlying asset price mantissa (scaled by 1e18).
<       *  Zero means the price is unavailable.
<       */
<     function getUnderlyingPrice(CToken cToken) external view returns (uint);
---
>      * @notice Get the underlying price of a cToken asset
>      * @param cToken The cToken to get the underlying price of
>      * @return The underlying asset price mantissa (scaled by 1e18).
>      *  Zero means the price is unavailable.
>      */
>     function getUnderlyingPrice(CToken cToken) external view returns (uint256);
Only in src/core/: ReactiveJumpRateModelV2.sol
diff -x .git -r ../compound-protocol/contracts/Reservoir.sol src/core/Reservoir.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
9a10,11
>     /// @notice The block number when the Reservoir started (immutable)
>     uint256 public dripStart;
11,12c13,14
<   /// @notice The block number when the Reservoir started (immutable)
<   uint public dripStart;
---
>     /// @notice Tokens per block that to drip to target (immutable)
>     uint256 public dripRate;
14,15c16,17
<   /// @notice Tokens per block that to drip to target (immutable)
<   uint public dripRate;
---
>     /// @notice Reference to token to drip (immutable)
>     EIP20Interface public token;
17,18c19,111
<   /// @notice Reference to token to drip (immutable)
<   EIP20Interface public token;
---
>     /// @notice Target to receive dripped tokens (immutable)
>     address public target;
> 
>     /// @notice Amount that has already been dripped
>     uint256 public dripped;
> 
>     /**
>      * @notice Constructs a Reservoir
>      * @param dripRate_ Numer of tokens per block to drip
>      * @param token_ The token to drip
>      * @param target_ The recipient of dripped tokens
>      */
>     constructor(
>         uint256 dripRate_,
>         EIP20Interface token_,
>         address target_
>     ) public {
>         require(dripRate_ > 0, "Drip rate should be greater than 0.");
>         require(address(token_) != address(0), "Drip token not defined.");
>         require(target_ != address(0), "Drip target not defined.");
>         dripStart = block.number;
>         dripRate = dripRate_;
>         token = token_;
>         target = target_;
>         dripped = 0;
>     }
> 
>     /**
>      * @notice Drips the maximum amount of tokens to match the drip rate since inception
>      * @dev Note: this will only drip up to the amount of tokens available.
>      * @return The amount of tokens dripped in this call
>      */
>     function drip() public returns (uint256) {
>         // First, read storage into memory
>         EIP20Interface token_ = token;
>         uint256 reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call
>         uint256 dripRate_ = dripRate;
>         uint256 dripStart_ = dripStart;
>         uint256 dripped_ = dripped;
>         address target_ = target;
>         uint256 blockNumber_ = block.number;
> 
>         // Next, calculate intermediate values
>         uint256 dripTotal_ = mul(
>             dripRate_,
>             blockNumber_ - dripStart_,
>             "dripTotal overflow"
>         );
>         uint256 deltaDrip_ = sub(dripTotal_, dripped_, "deltaDrip underflow");
>         uint256 toDrip_ = min(reservoirBalance_, deltaDrip_);
>         uint256 drippedNext_ = add(dripped_, toDrip_, "tautological");
> 
>         // Finally, write new `dripped` value and transfer tokens to target
>         dripped = drippedNext_;
>         token_.transfer(target_, toDrip_);
> 
>         return toDrip_;
>     }
> 
>     /* Internal helper functions for safe math */
> 
>     function add(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
>         uint256 c = a + b;
>         require(c >= a, errorMessage);
>         return c;
>     }
> 
>     function sub(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
>         require(b <= a, errorMessage);
>         uint256 c = a - b;
>         return c;
>     }
> 
>     function mul(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
>         if (a == 0) {
>             return 0;
>         }
>         uint256 c = a * b;
>         require(c / a == b, errorMessage);
>         return c;
>     }
20,95c113,118
<   /// @notice Target to receive dripped tokens (immutable)
<   address public target;
< 
<   /// @notice Amount that has already been dripped
<   uint public dripped;
< 
<   /**
<     * @notice Constructs a Reservoir
<     * @param dripRate_ Numer of tokens per block to drip
<     * @param token_ The token to drip
<     * @param target_ The recipient of dripped tokens
<     */
<   constructor(uint dripRate_, EIP20Interface token_, address target_) public {
<     dripStart = block.number;
<     dripRate = dripRate_;
<     token = token_;
<     target = target_;
<     dripped = 0;
<   }
< 
<   /**
<     * @notice Drips the maximum amount of tokens to match the drip rate since inception
<     * @dev Note: this will only drip up to the amount of tokens available.
<     * @return The amount of tokens dripped in this call
<     */
<   function drip() public returns (uint) {
<     // First, read storage into memory
<     EIP20Interface token_ = token;
<     uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call
<     uint dripRate_ = dripRate;
<     uint dripStart_ = dripStart;
<     uint dripped_ = dripped;
<     address target_ = target;
<     uint blockNumber_ = block.number;
< 
<     // Next, calculate intermediate values
<     uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, "dripTotal overflow");
<     uint deltaDrip_ = sub(dripTotal_, dripped_, "deltaDrip underflow");
<     uint toDrip_ = min(reservoirBalance_, deltaDrip_);
<     uint drippedNext_ = add(dripped_, toDrip_, "tautological");
< 
<     // Finally, write new `dripped` value and transfer tokens to target
<     dripped = drippedNext_;
<     token_.transfer(target_, toDrip_);
< 
<     return toDrip_;
<   }
< 
<   /* Internal helper functions for safe math */
< 
<   function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {
<     uint c = a + b;
<     require(c >= a, errorMessage);
<     return c;
<   }
< 
<   function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {
<     require(b <= a, errorMessage);
<     uint c = a - b;
<     return c;
<   }
< 
<   function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {
<     if (a == 0) {
<       return 0;
<     }
<     uint c = a * b;
<     require(c / a == b, errorMessage);
<     return c;
<   }
< 
<   function min(uint a, uint b) internal pure returns (uint) {
<     if (a <= b) {
<       return a;
<     } else {
<       return b;
---
>     function min(uint256 a, uint256 b) internal pure returns (uint256) {
>         if (a <= b) {
>             return a;
>         } else {
>             return b;
>         }
97d119
<   }
Only in src/core/: RewardsDistributorDelegate.sol
Only in src/core/: RewardsDistributorDelegator.sol
Only in src/core/: RewardsDistributorStorage.sol
diff -x .git -r ../compound-protocol/contracts/SafeMath.sol src/core/SafeMath.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
43c43,47
<     function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
---
>     function add(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
70c74,78
<     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
---
>     function sub(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
107c115,119
<     function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
---
>     function mul(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
147c159,163
<     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
---
>     function div(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
182c198,202
<     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
---
>     function mod(
>         uint256 a,
>         uint256 b,
>         string memory errorMessage
>     ) internal pure returns (uint256) {
diff -x .git -r ../compound-protocol/contracts/SimplePriceOracle.sol src/core/SimplePriceOracle.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
7,8c7,13
<     mapping(address => uint) prices;
<     event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);
---
>     mapping(address => uint256) prices;
>     event PricePosted(
>         address asset,
>         uint256 previousPriceMantissa,
>         uint256 requestedPriceMantissa,
>         uint256 newPriceMantissa
>     );
10,11c15
<     function _getUnderlyingAddress(CToken cToken) private view returns (address) {
<         address asset;
---
>     function getUnderlyingPrice(CToken cToken) public view returns (uint256) {
13c17
<             asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
---
>             return 1e18;
15c19
<             asset = address(CErc20(address(cToken)).underlying());
---
>             return prices[address(CErc20(address(cToken)).underlying())];
17d20
<         return asset;
20,26c23,32
<     function getUnderlyingPrice(CToken cToken) public view returns (uint) {
<         return prices[_getUnderlyingAddress(cToken)];
<     }
< 
<     function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {
<         address asset = _getUnderlyingAddress(cToken);
<         emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);
---
>     function setUnderlyingPrice(CToken cToken, uint256 underlyingPriceMantissa)
>         public
>     {
>         address asset = address(CErc20(address(cToken)).underlying());
>         emit PricePosted(
>             asset,
>             prices[asset],
>             underlyingPriceMantissa,
>             underlyingPriceMantissa
>         );
30c36
<     function setDirectPrice(address asset, uint price) public {
---
>     function setDirectPrice(address asset, uint256 price) public {
36c42
<     function assetPrices(address asset) external view returns (uint) {
---
>     function assetPrices(address asset) external view returns (uint256) {
40,41c46,52
<     function compareStrings(string memory a, string memory b) internal pure returns (bool) {
<         return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));
---
>     function compareStrings(string memory a, string memory b)
>         internal
>         pure
>         returns (bool)
>     {
>         return (keccak256(abi.encodePacked((a))) ==
>             keccak256(abi.encodePacked((b))));
diff -x .git -r ../compound-protocol/contracts/Timelock.sol src/core/Timelock.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
6c6
<     using SafeMath for uint;
---
>     using SafeMath for uint256;
10,17c10,38
<     event NewDelay(uint indexed newDelay);
<     event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);
<     event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);
<     event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);
< 
<     uint public constant GRACE_PERIOD = 14 days;
<     uint public constant MINIMUM_DELAY = 2 days;
<     uint public constant MAXIMUM_DELAY = 30 days;
---
>     event NewDelay(uint256 indexed newDelay);
>     event CancelTransaction(
>         bytes32 indexed txHash,
>         address indexed target,
>         uint256 value,
>         string signature,
>         bytes data,
>         uint256 eta
>     );
>     event ExecuteTransaction(
>         bytes32 indexed txHash,
>         address indexed target,
>         uint256 value,
>         string signature,
>         bytes data,
>         uint256 eta
>     );
>     event QueueTransaction(
>         bytes32 indexed txHash,
>         address indexed target,
>         uint256 value,
>         string signature,
>         bytes data,
>         uint256 eta
>     );
> 
>     uint256 public constant GRACE_PERIOD = 14 days;
>     uint256 public constant MINIMUM_DELAY = 2 days;
>     uint256 public constant MAXIMUM_DELAY = 30 days;
21c42
<     uint public delay;
---
>     uint256 public delay;
23c44
<     mapping (bytes32 => bool) public queuedTransactions;
---
>     mapping(bytes32 => bool) public queuedTransactions;
25,28c46,54
< 
<     constructor(address admin_, uint delay_) public {
<         require(delay_ >= MINIMUM_DELAY, "Timelock::constructor: Delay must exceed minimum delay.");
<         require(delay_ <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");
---
>     constructor(address admin_, uint256 delay_) public {
>         require(
>             delay_ >= MINIMUM_DELAY,
>             "Timelock::constructor: Delay must exceed minimum delay."
>         );
>         require(
>             delay_ <= MAXIMUM_DELAY,
>             "Timelock::setDelay: Delay must not exceed maximum delay."
>         );
34c60
<     function() external payable { }
---
>     function() external payable {}
36,39c62,74
<     function setDelay(uint delay_) public {
<         require(msg.sender == address(this), "Timelock::setDelay: Call must come from Timelock.");
<         require(delay_ >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");
<         require(delay_ <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");
---
>     function setDelay(uint256 delay_) public {
>         require(
>             msg.sender == address(this),
>             "Timelock::setDelay: Call must come from Timelock."
>         );
>         require(
>             delay_ >= MINIMUM_DELAY,
>             "Timelock::setDelay: Delay must exceed minimum delay."
>         );
>         require(
>             delay_ <= MAXIMUM_DELAY,
>             "Timelock::setDelay: Delay must not exceed maximum delay."
>         );
46c81,84
<         require(msg.sender == pendingAdmin, "Timelock::acceptAdmin: Call must come from pendingAdmin.");
---
>         require(
>             msg.sender == pendingAdmin,
>             "Timelock::acceptAdmin: Call must come from pendingAdmin."
>         );
54c92,95
<         require(msg.sender == address(this), "Timelock::setPendingAdmin: Call must come from Timelock.");
---
>         require(
>             msg.sender == address(this),
>             "Timelock::setPendingAdmin: Call must come from Timelock."
>         );
60,64c101,119
<     function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {
<         require(msg.sender == admin, "Timelock::queueTransaction: Call must come from admin.");
<         require(eta >= getBlockTimestamp().add(delay), "Timelock::queueTransaction: Estimated execution block must satisfy delay.");
< 
<         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
---
>     function queueTransaction(
>         address target,
>         uint256 value,
>         string memory signature,
>         bytes memory data,
>         uint256 eta
>     ) public returns (bytes32) {
>         require(
>             msg.sender == admin,
>             "Timelock::queueTransaction: Call must come from admin."
>         );
>         require(
>             eta >= getBlockTimestamp().add(delay),
>             "Timelock::queueTransaction: Estimated execution block must satisfy delay."
>         );
> 
>         bytes32 txHash = keccak256(
>             abi.encode(target, value, signature, data, eta)
>         );
71,74c126,140
<     function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {
<         require(msg.sender == admin, "Timelock::cancelTransaction: Call must come from admin.");
< 
<         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
---
>     function cancelTransaction(
>         address target,
>         uint256 value,
>         string memory signature,
>         bytes memory data,
>         uint256 eta
>     ) public {
>         require(
>             msg.sender == admin,
>             "Timelock::cancelTransaction: Call must come from admin."
>         );
> 
>         bytes32 txHash = keccak256(
>             abi.encode(target, value, signature, data, eta)
>         );
80,86c146,172
<     function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {
<         require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin.");
< 
<         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
<         require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn't been queued.");
<         require(getBlockTimestamp() >= eta, "Timelock::executeTransaction: Transaction hasn't surpassed time lock.");
<         require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), "Timelock::executeTransaction: Transaction is stale.");
---
>     function executeTransaction(
>         address target,
>         uint256 value,
>         string memory signature,
>         bytes memory data,
>         uint256 eta
>     ) public payable returns (bytes memory) {
>         require(
>             msg.sender == admin,
>             "Timelock::executeTransaction: Call must come from admin."
>         );
> 
>         bytes32 txHash = keccak256(
>             abi.encode(target, value, signature, data, eta)
>         );
>         require(
>             queuedTransactions[txHash],
>             "Timelock::executeTransaction: Transaction hasn't been queued."
>         );
>         require(
>             getBlockTimestamp() >= eta,
>             "Timelock::executeTransaction: Transaction hasn't surpassed time lock."
>         );
>         require(
>             getBlockTimestamp() <= eta.add(GRACE_PERIOD),
>             "Timelock::executeTransaction: Transaction is stale."
>         );
95c181,184
<             callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
---
>             callData = abi.encodePacked(
>                 bytes4(keccak256(bytes(signature))),
>                 data
>             );
99,100c188,194
<         (bool success, bytes memory returnData) = target.call.value(value)(callData);
<         require(success, "Timelock::executeTransaction: Transaction execution reverted.");
---
>         (bool success, bytes memory returnData) = target.call.value(value)(
>             callData
>         );
>         require(
>             success,
>             "Timelock::executeTransaction: Transaction execution reverted."
>         );
107c201
<     function getBlockTimestamp() internal view returns (uint) {
---
>     function getBlockTimestamp() internal view returns (uint256) {
111c205
< }
\ No newline at end of file
---
> }
diff -x .git -r ../compound-protocol/contracts/Unitroller.sol src/core/Unitroller.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
4a5
> 
6c7
<  * @title ComptrollerCore
---
>  * @title Unitroller
10a12,18
>     /**
>      * @notice Emitted when pendingComptrollerImplementation is changed
>      */
>     event NewPendingImplementation(
>         address oldPendingImplementation,
>         address newPendingImplementation
>     );
13,15c21,26
<       * @notice Emitted when pendingComptrollerImplementation is changed
<       */
<     event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);
---
>      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated
>      */
>     event NewImplementation(
>         address oldImplementation,
>         address newImplementation
>     );
18,20c29,31
<       * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated
<       */
<     event NewImplementation(address oldImplementation, address newImplementation);
---
>      * @notice Event emitted when the Fuse admin rights are changed
>      */
>     event FuseAdminRightsToggled(bool hasRights);
23,24c34,40
<       * @notice Emitted when pendingAdmin is changed
<       */
---
>      * @notice Event emitted when the admin rights are changed
>      */
>     event AdminRightsToggled(bool hasRights);
> 
>     /**
>      * @notice Emitted when pendingAdmin is changed
>      */
28,29c44,45
<       * @notice Emitted when pendingAdmin is accepted, which means admin is updated
<       */
---
>      * @notice Emitted when pendingAdmin is accepted, which means admin is updated
>      */
38d53
<     function _setPendingImplementation(address newPendingImplementation) public returns (uint) {
40,41c55,77
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);
---
>     function _setPendingImplementation(address newPendingImplementation)
>         public
>         returns (uint256)
>     {
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK
>                 );
>         }
> 
>         if (
>             !fuseAdmin.comptrollerImplementationWhitelist(
>                 comptrollerImplementation,
>                 newPendingImplementation
>             )
>         ) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK
>                 );
48c84,87
<         emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);
---
>         emit NewPendingImplementation(
>             oldPendingImplementation,
>             pendingComptrollerImplementation
>         );
50c89
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
54,58c93,97
<     * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation
<     * @dev Admin function for new implementation to accept it's role as implementation
<     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<     */
<     function _acceptImplementation() public returns (uint) {
---
>      * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation
>      * @dev Admin function for new implementation to accept it's role as implementation
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _acceptImplementation() public returns (uint256) {
60,61c99,107
<         if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);
---
>         if (
>             msg.sender != pendingComptrollerImplementation ||
>             pendingComptrollerImplementation == address(0)
>         ) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK
>                 );
73c119,149
<         emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);
---
>         emit NewPendingImplementation(
>             oldPendingImplementation,
>             pendingComptrollerImplementation
>         );
> 
>         return uint256(Error.NO_ERROR);
>     }
> 
>     /**
>      * @notice Toggles Fuse admin rights.
>      * @param hasRights Boolean indicating if the Fuse admin is to have rights.
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _toggleFuseAdminRights(bool hasRights) external returns (uint256) {
>         // Check caller = admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK
>                 );
>         }
> 
>         // Check that rights have not already been set to the desired value
>         if (fuseAdminHasRights == hasRights) return uint256(Error.NO_ERROR);
> 
>         // Set fuseAdminHasRights
>         fuseAdminHasRights = hasRights;
> 
>         // Emit FuseAdminRightsToggled()
>         emit FuseAdminRightsToggled(fuseAdminHasRights);
75c151
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
77a154,179
>     /**
>      * @notice Toggles admin rights.
>      * @param hasRights Boolean indicating if the admin is to have rights.
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _toggleAdminRights(bool hasRights) external returns (uint256) {
>         // Check caller = admin
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK
>                 );
>         }
> 
>         // Check that rights have not already been set to the desired value
>         if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);
> 
>         // Set adminHasRights
>         adminHasRights = hasRights;
> 
>         // Emit AdminRightsToggled()
>         emit AdminRightsToggled(hasRights);
> 
>         return uint256(Error.NO_ERROR);
>     }
80,85c182,190
<       * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
<       * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
<       * @param newPendingAdmin New pending admin.
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _setPendingAdmin(address newPendingAdmin) public returns (uint) {
---
>      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
>      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
>      * @param newPendingAdmin New pending admin.
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _setPendingAdmin(address newPendingAdmin)
>         public
>         returns (uint256)
>     {
87,88c192,197
<         if (msg.sender != admin) {
<             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
---
>         if (!hasAdminRights()) {
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK
>                 );
100c209
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
104,108c213,217
<       * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
<       * @dev Admin function for pending admin to accept role and update admin
<       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
<       */
<     function _acceptAdmin() public returns (uint) {
---
>      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
>      * @dev Admin function for pending admin to accept role and update admin
>      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
>      */
>     function _acceptAdmin() public returns (uint256) {
111c220,224
<             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
---
>             return
>                 fail(
>                     Error.UNAUTHORIZED,
>                     FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK
>                 );
127c240
<         return uint(Error.NO_ERROR);
---
>         return uint256(Error.NO_ERROR);
135c248,273
<     function () payable external {
---
>     function() external payable {
>         // Check for automatic implementation
>         if (msg.sender != address(this)) {
>             (bool callSuccess, bytes memory data) = address(this).staticcall(
>                 abi.encodeWithSignature("autoImplementation()")
>             );
>             bool autoImplementation;
>             if (callSuccess) (autoImplementation) = abi.decode(data, (bool));
> 
>             if (autoImplementation) {
>                 address latestComptrollerImplementation = fuseAdmin
>                     .latestComptrollerImplementation(comptrollerImplementation);
> 
>                 if (
>                     comptrollerImplementation != latestComptrollerImplementation
>                 ) {
>                     address oldImplementation = comptrollerImplementation; // Save current value for inclusion in log
>                     comptrollerImplementation = latestComptrollerImplementation;
>                     emit NewImplementation(
>                         oldImplementation,
>                         comptrollerImplementation
>                     );
>                 }
>             }
>         }
> 
140,141c278,279
<               let free_mem_ptr := mload(0x40)
<               returndatacopy(free_mem_ptr, 0, returndatasize)
---
>             let free_mem_ptr := mload(0x40)
>             returndatacopy(free_mem_ptr, 0, returndatasize)
143,145c281,287
<               switch success
<               case 0 { revert(free_mem_ptr, returndatasize) }
<               default { return(free_mem_ptr, returndatasize) }
---
>             switch success
>             case 0 {
>                 revert(free_mem_ptr, returndatasize)
>             }
>             default {
>                 return(free_mem_ptr, returndatasize)
>             }
diff -x .git -r ../compound-protocol/contracts/WhitePaperInterestRateModel.sol src/core/WhitePaperInterestRateModel.sol
1c1
< pragma solidity ^0.5.16;
---
> pragma solidity 0.5.17;
7,10c7,10
<   * @title Compound's WhitePaperInterestRateModel Contract
<   * @author Compound
<   * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper
<   */
---
>  * @title Compound's WhitePaperInterestRateModel Contract
>  * @author Compound
>  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper
>  */
12c12
<     using SafeMath for uint;
---
>     using SafeMath for uint256;
14c14,17
<     event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);
---
>     event NewInterestParams(
>         uint256 baseRatePerBlock,
>         uint256 multiplierPerBlock
>     );
19c22
<     uint public constant blocksPerYear = 2102400;
---
>     uint256 public constant blocksPerYear = 2372500; // 6500 blocks/day * 365 days/year
24c27
<     uint public multiplierPerBlock;
---
>     uint256 public multiplierPerBlock;
29c32
<     uint public baseRatePerBlock;
---
>     uint256 public baseRatePerBlock;
36c39
<     constructor(uint baseRatePerYear, uint multiplierPerYear) public {
---
>     constructor(uint256 baseRatePerYear, uint256 multiplierPerYear) public {
50c53,57
<     function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {
---
>     function utilizationRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) public pure returns (uint256) {
66,67c73,78
<     function getBorrowRate(uint cash, uint borrows, uint reserves) public view returns (uint) {
<         uint ur = utilizationRate(cash, borrows, reserves);
---
>     function getBorrowRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves
>     ) public view returns (uint256) {
>         uint256 ur = utilizationRate(cash, borrows, reserves);
79,83c90,102
<     function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {
<         uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);
<         uint borrowRate = getBorrowRate(cash, borrows, reserves);
<         uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
<         return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
---
>     function getSupplyRate(
>         uint256 cash,
>         uint256 borrows,
>         uint256 reserves,
>         uint256 reserveFactorMantissa
>     ) public view returns (uint256) {
>         uint256 oneMinusReserveFactor = uint256(1e18).sub(
>             reserveFactorMantissa
>         );
>         uint256 borrowRate = getBorrowRate(cash, borrows, reserves);
>         uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
>         return
>             utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
